{"meta":{"title":"并非菜鸟的博客","subtitle":null,"description":null,"author":"YaxuSong","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"一、安装环境","slug":"一、安装环境","date":"2018-01-15T08:19:26.000Z","updated":"2018-01-15T08:19:26.435Z","comments":true,"path":"2018/01/15/一、安装环境/","link":"","permalink":"http://yoursite.com/2018/01/15/一、安装环境/","excerpt":"","text":"","categories":[],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/tags/读书笔记/"}]},{"title":"LinuxMySQL的安装","slug":"LinuxMySQL的安装","date":"2018-01-15T02:20:07.000Z","updated":"2018-01-15T05:23:38.513Z","comments":true,"path":"2018/01/15/LinuxMySQL的安装/","link":"","permalink":"http://yoursite.com/2018/01/15/LinuxMySQL的安装/","excerpt":"一、查看是否安装了MySQL使用命令：1rpm -qa|grep -i mysql 如果使用centos，可能会出现冲突，解决冲突需要卸载mariadb首先查看是否安装了Mariadb1rpm -qa|grep mariadb 然后卸载1rpm -e mariadb-libs-5.5.56-2.el7.x86_64 强制卸载(可选):1rpm -e --nodeps mariadb-libs-5.5.56-2.el7.x86_64","text":"一、查看是否安装了MySQL使用命令：1rpm -qa|grep -i mysql 如果使用centos，可能会出现冲突，解决冲突需要卸载mariadb首先查看是否安装了Mariadb1rpm -qa|grep mariadb 然后卸载1rpm -e mariadb-libs-5.5.56-2.el7.x86_64 强制卸载(可选):1rpm -e --nodeps mariadb-libs-5.5.56-2.el7.x86_64 二、如果安装了需删除已安装版本删除命令：12rpm -e --nodeps 包名( rpm -ev mysql-4.1.12-3.RHEL4.1 ) 删除老版本mysql的开发头文件和库命令：12rm -fr /usr/lib/mysqlrm -fr /usr/include/mysql 注意：卸载后/var/lib/mysql中的数据及/etc/my.cnf不会删除，如果确定没用后就手工删除12rm -f /etc/my.cnfrm -fr /var/lib/mysql 三、安装mysql准备环境我自mysql官网下载通用的Linux版本安装包mysql-5.7.20-linux-glibc2.12-x86_64.tar.gz将下载好的包放在 /usr/local 目录下，或者执行命令：12cd /usr/localwget https://cdn.mysql.com//Downloads/MySQL-5.7/mysql-5.7.20-linux-glibc2.12-x86_64.tar.gz 解压下载的文件1tar -zxvf mysql-5.7.20-linux-glibc2.12-x86_64.tar.gz 将解压之后的所有文件移动到/usr/local/mysql1mv ./mysql-5.7.20-linux-glibc2.12-x86_64/* ./mysql 为mysql创建系统用户(可选，新版本会自动创建相应用户)12groupadd mysqluseradd -r -g mysql mysql //-r参数表示mysql用户是系统用户，不可用于登录系统并变更mysql安装目录的所属用户和用户组12chown -R mysql:mysql mysql// -R 迭代处理 四、 安装和初始化初始化数据库1./bin/mysqld --initialize --user=mysql --basedir=/usr/local/mysql --datadir=/usr/local/mysql/data --lc_messages_dir=/usr/local/mysql/share --lc_messages=en_US 记录刚刚输出的密码： jk9tEao&lt;94MC 配置/etc/my.cnf my.cnf 五、 启动登录和设置密码切换到mysql安装目录的bin下启动1./mysqld_safe --user=mysql 启动后可能无法使用当前窗口 登录进去设置新的密码：1./mysql -u root -p 12set password=password(\"root\");flush privileges; 六、 添加到服务 切换到 support-files目录下，并执行以下命令1cp mysql.server /etc/init.d/mysql 然后停止当前进程，使用服务启动mysql1service mysql start 并添加mysql环境变量在 /etc/profile 的文件末尾追加： export PATH=$PATH:/usr/local/mysql/bin保存后执行1source /etc/profile 最后使用新密码登录到mysql","categories":[],"tags":[{"name":"ATLASSIAN产品安装","slug":"ATLASSIAN产品安装","permalink":"http://yoursite.com/tags/ATLASSIAN产品安装/"},{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"Bitbucket的安装","slug":"Bitbucket的安装","date":"2018-01-15T01:57:45.000Z","updated":"2018-01-15T02:10:13.599Z","comments":true,"path":"2018/01/15/Bitbucket的安装/","link":"","permalink":"http://yoursite.com/2018/01/15/Bitbucket的安装/","excerpt":"","text":"一、安装环境1、数据库:MySQL(这里使用的是MySQL) 2、操作系统：Centos或者是RHEL 3、网络环境：无法连接到公网 4、准备文件： atlassian-jira-software-7.6.0-x64.bin mysql-connector-java-5.1.44-bin.jar nginx-1.12.2.tar.gz(反向代理) git","categories":[],"tags":[{"name":"ATLASSIAN产品安装","slug":"ATLASSIAN产品安装","permalink":"http://yoursite.com/tags/ATLASSIAN产品安装/"}]},{"title":"JIRA修改license","slug":"JIRA修改license","date":"2018-01-11T05:27:01.000Z","updated":"2018-01-15T02:03:07.256Z","comments":true,"path":"2018/01/11/JIRA修改license/","link":"","permalink":"http://yoursite.com/2018/01/11/JIRA修改license/","excerpt":"If for whatever reason the JIRA license key needs to be extracted from the database, it can be done with the following SQL:12345SELECT propertyvalue AS license FROM propertytext pt JOIN propertyentry pe ON pt.id = pe.id WHERE property_key = 'License20';","text":"If for whatever reason the JIRA license key needs to be extracted from the database, it can be done with the following SQL:12345SELECT propertyvalue AS license FROM propertytext pt JOIN propertyentry pe ON pt.id = pe.id WHERE property_key = 'License20'; (info) This is tested on PostgreSQL and may need modifying for other DBMS such as Oracle or SQL Server. For JIRA 7.0.5 and above: 1SELECT * FROM productlicense; Updating the LicenseThe license can be updated as per Specifying your License Details. If this does not work, it is possible to do so with an update to the database however it is not recommended. This is because it can cause data integrity problems and may lead to data corruption. If you choose to do this please keep in mind we may be unable to provide support. Always back up your data before performing any modification to the database. If possible, try your modifications on a test server. Stop JIRA.Execute the following to locate the ID to modify: JIRA 7.0.4 and below12345SELECT pt.id FROM propertytext pt JOIN propertyentry pe ON pt.id = pe.id WHERE property_key = 'License20'; JIRA 7.0.4 and above1SELECT * FROM productlicense; Update the license with the following: JIRA 7.0.4 and below1UPDATE propertytext SET propertyvalue = '&lt;license_string&gt;' WHERE id = &lt;id_from_step_2&gt;; JIRA 7.0.4 and above1update productlicense set license ='&lt;license_string&gt;' WHERE id= &lt;id_from_step_2&gt;; Start JIRA.","categories":[],"tags":[{"name":"ATLASSIAN产品安装","slug":"ATLASSIAN产品安装","permalink":"http://yoursite.com/tags/ATLASSIAN产品安装/"}]},{"title":"rsync的使用与配置","slug":"rsync的使用与配置","date":"2018-01-09T03:31:15.000Z","updated":"2018-01-09T06:34:27.029Z","comments":true,"path":"2018/01/09/rsync的使用与配置/","link":"","permalink":"http://yoursite.com/2018/01/09/rsync的使用与配置/","excerpt":"一、什么是rsyncrsync，remote synchronize顾名思意就知道它是一款实现远程同步功能的软件，它在同步文件的同时，可以保持原来文件的权限、时间、软硬链接等附加信息。 rsync是用 “rsync 算法”提供了一个客户机和远程文件服务器的文件同步的快速方法，而且可以通过ssh方式来传输文件，这样其保密性也非常好，另外它还是免费的软件。 二、rsync的安装rysnc的官方网站：http://rsync.samba.org可以从上面得到最新的版本。目前最新版是3.1.2。当然，因为rsync是一款如此有用的软件，所以很多Linux的发行版本都将它收录在内了。","text":"一、什么是rsyncrsync，remote synchronize顾名思意就知道它是一款实现远程同步功能的软件，它在同步文件的同时，可以保持原来文件的权限、时间、软硬链接等附加信息。 rsync是用 “rsync 算法”提供了一个客户机和远程文件服务器的文件同步的快速方法，而且可以通过ssh方式来传输文件，这样其保密性也非常好，另外它还是免费的软件。 二、rsync的安装rysnc的官方网站：http://rsync.samba.org可以从上面得到最新的版本。目前最新版是3.1.2。当然，因为rsync是一款如此有用的软件，所以很多Linux的发行版本都将它收录在内了。 软件包安装 命令 平台 # sudo apt-get install rsync 注：在debian、ubuntu 等在线安装方法； # yum install rsync 注：Fedora、Redhat 等在线安装方法； # rpm -ivh rsync 注：Fedora、Redhat 等rpm包安装方法； 其它Linux发行版，请用相应的软件包管理方法来安装。 源码包安装 tar xvf rsync-xxx.tar.gz cd rsync-xxx ./configure –prefix=/usr ;make ;make install 注：在用源码包编译安装之前，您得安装gcc等编译开具才行； 三、rsync的配置rsync的主要有以下三个配置文件rsyncd.conf(主配置文件)、rsyncd.secrets(密码文件)、rsyncd.motd(rysnc服务器信息)比如我们要备份服务器上的/home和/opt，在/home中我想把easylife和samba目录排除在外；12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 # Distributed under the terms of the GNU General Public License v2 # Minimal configuration file for rsync daemon # See rsync(1) and rsyncd.conf(5) man pages for help # This line is required by the /etc/init.d/rsyncd script pid file = /var/run/rsyncd.pid port = 873 address = 192.168.1.171 #uid = nobody #gid = nobody uid = root gid = root use chroot = yes read only = yes #limit access to private LANs hosts allow=192.168.1.0/255.255.255.0 10.0.1.0/255.255.255.0 hosts deny=* max connections = 5 motd file = /etc/rsyncd.motd #This will give you a separate log file #log file = /var/log/rsync.log #This will log every file transferred - up to 85,000+ per user, per sync #transfer logging = yes log format = %t %a %m %f %b syslog facility = local3 timeout = 300 [rhel4home] path = /home list=yes ignore errors auth users = root secrets file = /etc/rsyncd.secrets comment = This is RHEL 4 data exclude = easylife/ samba/ [rhel4opt] path = /opt list=no ignore errors comment = This is RHEL 4 opt auth users = easylife secrets file = /etc/rsyncd/rsyncd.secrets 注：关于auth users是必须在服务器上存在的真实的系统用户，如果你想用多个用户以,号隔开，比如auth users = easylife,root 设定密码文件 密码文件格式很简单，rsyncd.secrets的内容格式为： 用户名:密码 我们在例子中rsyncd.secrets的内容如下类似的；在文档中说，有些系统不支持长密码，自己尝试着设置一下吧。12 easylife:keer root:mike chown root.root rsyncd.secrets #修改属主 chmod 600 rsyncd.secrets #修改权限 注：1、将rsyncd.secrets这个密码文件的文件属性设为root拥有, 且权限要设为600, 否则无法备份成功! 出于安全目的，文件的属性必需是只有属主可读。 2、这里的密码值得注意，为了安全你不能把系统用户的密码写在这里。比如你的系统用户easylife密码是000000，为了安全你可以让rsync中的easylife为keer。这和samba的用户认证的密码原理是差不多的。 设定rsyncd.motd 文件; 它是定义rysnc服务器信息的，也就是用户登录信息。比如让用户知道这个服务器是谁提供的等；类似ftp服务器登录时，我们所看到的 linuxsir.org ftp ……。 当然这在全局定义变量时，并不是必须的，你可以用#号注掉，或删除；我在这里写了一个 rsyncd.motd的内容为：1234 ++++++++++++++++++++++++++++++++++++++++++++++ Welcome to use the mike.org.cn rsync services!2002------2009 ++++++++++++++++++++++++++++++++++++++++++++++ 四、启动rsync服务器 相当简单，有以下几种方法 A、–daemon参数方式，是让rsync以服务器模式运行 #/usr/bin/rsync –daemon –config=/etc/rsyncd/rsyncd.conf #–config用于指定rsyncd.conf的位置,如果在/etc下可以不写 B、xinetd方式 修改services加入如下内容 # nano -w /etc/services rsync 873/tcp # rsync rsync 873/udp # rsync 这一步一般可以不做，通常都有这两行(我的RHEL4和GENTOO默认都有)。修改的目的是让系统知道873端口对应的服务名为rsync。如没有的话就自行加入。 设定 /etc/xinetd.d/rsync, 简单例子如下: # default: off # description: The rsync server is a good addition to am ftp server, as it \\ # allows crc checksumming etc. service rsync { disable = no socket_type = stream wait = no user = root server = /usr/bin/rsync server_args = –daemon log_on_failure += USERID } 上述, 主要是要打开rsync這個daemon, 一旦有rsync client要连接時, xinetd会把它转介給 rsyncd(port 873)。然后service xinetd restart, 使上述设定生效. rsync服务器和防火墙 Linux 防火墙是用iptables，所以我们至少在服务器端要让你所定义的rsync 服务器端口通过，客户端上也应该让通过。 #iptables -A INPUT -p tcp -m state –state NEW -m tcp –dport 873 -j ACCEPT #iptables -L 查看一下防火墙是不是打开了 873端口 如果你不太懂防火墙的配置，可以先service iptables stop 将防火墙关掉。当然在生产环境这是很危险的，做实验才可以这么做哟！ 五、通过rsync客户端来同步数据B1、列出rsync 服务器上的所提供的同步内容； 首先：我们看看rsync服务器上提供了哪些可用的数据源 # rsync –list-only root@192.168.145.5:: ++++++++++++++++++++++++++++++++++++++++++++++ Welcome to use the mike.org.cn rsync services! 2002——2009 ++++++++++++++++++++++++++++++++++++++++++++++ rhel4home This is RHEL 4 data 注：前面是rsync所提供的数据源，也就是我们在rsyncd.conf中所写的[rhel4home]模块。而“This is RHEL 4 data”是由[rhel4home]模块中的 comment = This is RHEL 4 data 提供的；为什么没有把rhel4opt数据源列出来呢？因为我们在[rhel4opt]中已经把list=no了。 $ rsync –list-only root@192.168.145.5::rhel4home ++++++++++++++++++++++++++++++++++++++++++++++ Welcome to use the mike.org.cn rsync services! 2002——2009 ++++++++++++++++++++++++++++++++++++++++++++++ Password: drwxr-xr-x 4096 2009/03/15 21:33:13 . -rw-r–r– 1018 2009/03/02 02:33:41 ks.cfg -rwxr-xr-x 21288 2009/03/15 21:33:13 wgetpaste drwxrwxr-x 4096 2008/10/28 21:04:05 cvsroot drwx—— 4096 2008/11/30 16:30:58 easylife drwsr-sr-x 4096 2008/09/20 22:18:05 giddir drwx—— 4096 2008/09/29 14:18:46 quser1 drwx—— 4096 2008/09/27 14:38:12 quser2 drwx—— 4096 2008/11/14 06:10:19 test drwx—— 4096 2008/09/22 16:50:37 vbird1 drwx—— 4096 2008/09/19 15:28:45 vbird2 后面的root@ip中，root是指定密码文件中的用户名，之后的::rhel4home这是rhel4home模块名 B2、rsync客户端同步数据； #rsync -avzP root@192.168.145.5::rhel4home rhel4home Password: 这里要输入root的密码，是服务器端rsyncd.secrets提供的。在前面的例子中我们用的是mike，输入的密码并不回显，输好就回车。 注： 这个命令的意思就是说，用root用户登录到服务器上，把rhel4home数据，同步到本地当前目录rhel4home上。当然本地的目录是可以你自己 定义的。如果当你在客户端上当前操作的目录下没有rhel4home这个目录时，系统会自动为你创建一个；当存在rhel4home这个目录中，你要注意 它的写权限。 #rsync -avzP –delete linuxsir@linuxsir.org::rhel4home rhel4home 这回我们引入一个–delete 选项，表示客户端上的数据要与服务器端完全一致，如果 linuxsirhome目录中有服务器上不存在的文件，则删除。最终目的是让linuxsirhome目录上的数据完全与服务器上保持一致；用的时候要 小心点，最好不要把已经有重要数所据的目录，当做本地更新目录，否则会把你的数据全部删除； 設定 rsync client 设定密码文件 #rsync -avzP –delete –password-file=rsyncd.secrets root@192.168.145.5::rhel4home rhel4home 这次我们加了一个选项 –password-file=rsyncd.secrets，这是当我们以root用户登录rsync服务器同步数据时，密码将读取rsyncd.secrets这个文件。这个文件内容只是root用户的密码。我们要如下做； # touch rsyncd.secrets # chmod 600 rsyncd.secrets # echo “mike”&gt; rsyncd.secrets # rsync -avzP –delete –password-file=rsyncd.secrets root@192.168.145.5::rhel4home rhel4home 注：这里需要注意的是这份密码文件权限属性要设得只有属主可读。 这样就不需要密码了；其实这是比较重要的，因为服务器通过crond 计划任务还是有必要的； B3、让rsync客户端自动与服务器同步数据 服务器是重量级应用，所以数据的网络备份还是极为重要的。我们可以在生产型服务器上配置好rsync 服务器。我们可以把一台装有rysnc机器当做是备份服务器。让这台备份服务器，每天在早上4点开始同步服务器上的数据；并且每个备份都是完整备份。有时 硬盘坏掉，或者服务器数据被删除，完整备份还是相当重要的。这种备份相当于每天为服务器的数据做一个镜像，当生产型服务器发生事故时，我们可以轻松恢复数 据，能把数据损失降到最低；是不是这么回事？？ step1：创建同步脚本和密码文件 #mkdir /etc/cron.daily.rsync #cd /etc/cron.daily.rsync #touch rhel4home.sh rhel4opt.sh #chmod 755 /etc/cron.daily.rsync/.sh #mkdir /etc/rsyncd/ #touch /etc/rsyncd/rsyncrhel4root.secrets #touch /etc/rsyncd/rsyncrhel4easylife.secrets #chmod 600 /etc/rsyncd/rsync. 注： 我们在 /etc/cron.daily/中创建了两个文件rhel4home.sh和rhel4opt.sh ，并且是权限是755的。创建了两个密码文件root用户用的是rsyncrhel4root.secrets ，easylife用户用的是 rsyncrhel4easylife.secrets，权限是600； 我们编辑rhel4home.sh，内容是如下的： #!/bin/sh #backup 192.168.145.5:/home /usr/bin/rsync -avzP –password-file=/etc/rsyncd/rsyncrhel4root.secrets root@192.168.145.5::rhel4home /home/rhel4homebak/$(date +’%m-%d-%y’) 我们编辑 rhel4opt.sh ，内容是： #!/bin/sh #backup 192.168.145.5:/opt /usr/bin/rsync -avzP –password-file=/etc/rsyncd/rsyncrhel4easylife.secrets easylife@192.168.145.5::rhel4opt /home/rhel4hoptbak/$(date +’%m-%d-%y’) 注：你可以把rhel4home.sh和rhel4opt.sh的内容合并到一个文件中，比如都写到rhel4bak.sh中； 接着我们修改 /etc/rsyncd/rsyncrhel4root.secrets和rsyncrhel4easylife.secrets的内容； # echo “mike” &gt; /etc/rsyncd/rsyncrhel4root.secrets # echo “keer”&gt; /etc/rsyncd/rsyncrhel4easylife.secrets 然后我们再/home目录下创建rhel4homebak 和rhel4optbak两个目录，意思是服务器端的rhel4home数据同步到备份服务器上的/home/rhel4homebak 下，rhel4opt数据同步到 /home/rhel4optbak/目录下。并按年月日归档创建目录；每天备份都存档； #mkdir /home/rhel4homebak #mkdir /home/rhel4optbak step2：修改crond服务器的配置文件 加入到计划任务 #crontab -e 加入下面的内容： # Run daily cron jobs at 4:10 every day backup rhel4 data: 10 4 * /usr/bin/run-parts /etc/cron.daily.rsync 1&gt; /dev/null 注：第一行是注释，是说明内容，这样能自己记住。 第二行表示在每天早上4点10分的时候，运行 /etc/cron.daily.rsync 下的可执行脚本任务； 配置好后，要重启crond 服务器； # killall crond 注：杀死crond 服务器的进程； # ps aux |grep crond 注：查看一下是否被杀死； # /usr/sbin/crond 注：启动 crond 服务器； # ps aux |grep crond 注：查看一下是否启动了？ root 3815 0.0 0.0 1860 664 ? S 14:44 0:00 /usr/sbin/crond root 3819 0.0 0.0 2188 808 pts/1 S+ 14:45 0:00 grep crond","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"最近电脑重装了，导致电脑里边的博客全没了","slug":"最近电脑重装了，导致电脑里边的博客全没了","date":"2018-01-08T09:59:56.000Z","updated":"2018-01-08T10:03:59.693Z","comments":true,"path":"2018/01/08/最近电脑重装了，导致电脑里边的博客全没了/","link":"","permalink":"http://yoursite.com/2018/01/08/最近电脑重装了，导致电脑里边的博客全没了/","excerpt":"难受的事情发生了，上周的时候电脑出现无法进入系统的毛病，一直重启，一直想重做电脑的我，也正好趁着这次机会重做了系统，但是悲剧发生了。首先我没有还原系统，直接进行的系统重置，导致我的很多开发环境都没了。","text":"难受的事情发生了，上周的时候电脑出现无法进入系统的毛病，一直重启，一直想重做电脑的我，也正好趁着这次机会重做了系统，但是悲剧发生了。首先我没有还原系统，直接进行的系统重置，导致我的很多开发环境都没了。 其次，我的博客没有备份….所以今天有点时间，把博客的环境安装上了，但是md的文件没有了，原来的html网页还在，我在考虑怎么恢复。 超级难受","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"jira安装","slug":"jira安装","date":"2017-12-15T08:20:04.000Z","updated":"2018-01-15T08:21:02.176Z","comments":true,"path":"2017/12/15/jira安装/","link":"","permalink":"http://yoursite.com/2017/12/15/jira安装/","excerpt":"","text":"一、安装环境1、数据库:MySQL(这里使用的是MySQL) 2、操作系统：Centos或者是RHEL 3、网络环境：无法连接到公网 4、准备文件： atlassian-jira-software-7.6.0-x64.binmysql-connector-java-5.1.44-bin.jarnginx-1.12.2.tar.gz(反向代理) 二、准备环境1、分别在/opt/下创建好两个目录 安装目录 mkdir -p /opt/atlassian/jirahome目录 mkdir -p /opt/atlassian/jira-home 2、copy mysql-connector-java-5.1.44-bin.jar到安装目录/lib/下 cp ./mysql-connector-java-5.1.44-bin.jar /opt/atlassian/jira/lib 3、chmod a+x atlassian-jira-software-7.6.0-x64.bin 4、切换到管理员用户./atlassian-jira-software-7.6.0-x64.bin5、安装步骤","categories":[],"tags":[{"name":"ATLASSIAN产品安装","slug":"ATLASSIAN产品安装","permalink":"http://yoursite.com/tags/ATLASSIAN产品安装/"}]},{"title":"Nginx代理Atlassian产品(2):Use Domain:*.mydomain.com","slug":"Nginx代理Atlassian产品-2-Use-Domain-mydomain-com","date":"2017-12-13T08:15:05.000Z","updated":"2018-01-15T08:15:40.405Z","comments":true,"path":"2017/12/13/Nginx代理Atlassian产品-2-Use-Domain-mydomain-com/","link":"","permalink":"http://yoursite.com/2017/12/13/Nginx代理Atlassian产品-2-Use-Domain-mydomain-com/","excerpt":"","text":"","categories":[],"tags":[{"name":"ATLASSIAN产品安装","slug":"ATLASSIAN产品安装","permalink":"http://yoursite.com/tags/ATLASSIAN产品安装/"}]},{"title":"Nginx代理Atlassian产品(1):Use Domain:www.mydomain.com/*","slug":"Nginx代理Atlassian产品-1-Use-Domain-www-mydomain-com","date":"2017-12-13T07:07:32.000Z","updated":"2018-01-15T07:31:55.223Z","comments":true,"path":"2017/12/13/Nginx代理Atlassian产品-1-Use-Domain-www-mydomain-com/","link":"","permalink":"http://yoursite.com/2017/12/13/Nginx代理Atlassian产品-1-Use-Domain-www-mydomain-com/","excerpt":"","text":"一、配置JIRA1.配置/conf/server.xml修改前 &lt;Context docBase=&quot;${catalina.home}/atlassian-jira&quot; path=&quot;&quot; reloadable=&quot;false&quot; useHttpOnly=&quot;true&quot;&gt; 修改后 &lt;Context docBase=&quot;${catalina.home}/atlassian-jira&quot; path=&quot;/jira&quot; reloadable=&quot;false&quot; useHttpOnly=&quot;true&quot;&gt; 添加proxyName和proxyPort &lt;!-- Nginx Proxy Connector --&gt; &lt;Connector port=&quot;8080&quot; maxThreads=&quot;150&quot; minSpareThreads=&quot;25&quot; connectionTimeout=&quot;20000&quot; enableLookups=&quot;false&quot; maxHttpHeaderSize=&quot;8192&quot; protocol=&quot;HTTP/1.1&quot; useBodyEncodingForURI=&quot;false&quot; redirectPort=&quot;8443&quot; acceptCount=&quot;100&quot; disableUploadTimeout=&quot;true&quot; proxyName=&quot;www.atlassian.com&quot; proxyPort=&quot;80&quot;/&gt; &lt;!-- OPTIONAL,Nginx Proxy Connector with https --&gt; &lt;Connector port=&quot;8081&quot; maxThreads=&quot;150&quot; minSpareThreads=&quot;25&quot; connectionTimeout=&quot;20000&quot; enableLookups=&quot;false&quot; maxHttpHeaderSize=&quot;8192&quot; protocol=&quot;HTTP/1.1&quot; useBodyEncodingForURI=&quot;false&quot; redirectPort=&quot;8443&quot; acceptCount=&quot;100&quot; disableUploadTimeout=&quot;true&quot; proxyName=&quot;www.atlassian.com&quot; proxyPort=&quot;443&quot; scheme=&quot;https&quot; secure=&quot;true&quot;/&gt; &lt;!-- Standard HTTP Connector --&gt; &lt;Connector port=&quot;8082&quot; maxThreads=&quot;150&quot; minSpareThreads=&quot;25&quot; connectionTimeout=&quot;20000&quot; enableLookups=&quot;false&quot; maxHttpHeaderSize=&quot;8192&quot; protocol=&quot;HTTP/1.1&quot; useBodyEncodingForURI=&quot;false&quot; redirectPort=&quot;8443&quot; acceptCount=&quot;100&quot; disableUploadTimeout=&quot;true&quot;/&gt; 2.配置/conf/nginx.confserver { listen 80; server_name www.atlassian.com; location /jira { proxy_set_header X-Forwarded-Host $host; proxy_set_header X-Forwarded-Server $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://jira-hostname:8080/jira; client_max_body_size 100M; } } 二、配置bitbucket1.配置/shared/bitbucket.propertiesserver.port=7990 server.secure=true server.scheme=http server.proxy-port=80 server.proxy-name=mydomain.com server.context-path=/bitbucket 2.配置/conf/nginx.confserver { listen 80; server_name mydomain.com; location /bitbucket { proxy_pass http://localhost:7990; proxy_set_header X-Forwarded-Host $host; proxy_set_header X-Forwarded-Server $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Real-IP $remote_addr; proxy_redirect off; } } 三、配置confluence1.配置/conf/server.xml修改前 &lt;Context path=&quot;&quot; docBase=&quot;../confluence&quot; debug=&quot;0&quot; reloadable=&quot;false&quot;&gt; 修改后 &lt;Context path=&quot;/confluence&quot; docBase=&quot;../confluence&quot; debug=&quot;0&quot; reloadable=&quot;false&quot;&gt; 添加proxyName和proxyPort &lt;Connector port=&quot;8090&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; maxThreads=&quot;48&quot; minSpareThreads=&quot;10&quot; enableLookups=&quot;false&quot; acceptCount=&quot;10&quot; debug=&quot;0&quot; URIEncoding=&quot;UTF-8&quot; protocol=&quot;org.apache.coyote.http11.Http11NioProtocol&quot; proxyName=&quot;www.mydomain.com&quot; proxyPort=&quot;80&quot; scheme=&quot;http&quot;/&gt; 2.配置/conf/nginx.confserver { listen 80; server_name www.mydomain.com; location /confluence { client_max_body_size 100m; proxy_set_header X-Forwarded-Host $host; proxy_set_header X-Forwarded-Server $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://localhost:8090/confluence; } location /synchrony { proxy_set_header X-Forwarded-Host $host; proxy_set_header X-Forwarded-Server $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://localhost:8091/synchrony; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection &quot;Upgrade&quot;; } } 四、配置bamboo1.配置/conf/server.xml修改path &lt;Context path=&quot;/bamboo&quot; docBase=&quot;${catalina.home}/atlassian-bamboo&quot; reloadable=&quot;false&quot; useHttpOnly=&quot;true&quot;&gt; .... &lt;/Context&gt; 添加scheme、proxyName和proxyPort &lt;Connector port=&quot;8085&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; useBodyEncodingForURI=&quot;false&quot; .... .... scheme=&quot;http&quot; proxyName=&quot;www.mydomain.com&quot; proxyPort=&quot;80&quot; /&gt; 2.配置/conf/nginx.confserver { listen 80; server_name www.mydomain.com; location /bamboo { proxy_pass http://localhost:8085/bamboo; proxy_set_header X-Forwarded-Host $host; proxy_set_header X-Forwarded-Server $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Real-IP $remote_addr; proxy_redirect off; } } 五、配置fisheye1.配置/config.xml修改前 &lt;web-server&gt; &lt;http bind=&quot;:8060&quot;/&gt; &lt;/web-server&gt; 修改后 &lt;web-server site-url=&quot;http://www.mydomain.com&quot; context=&quot;/fisheye&quot;&gt; &lt;http bind=&quot;:8060&quot; proxy-host=&quot;www.mydomain.com&quot; proxy-port=&quot;80&quot; proxy-scheme=&quot;http&quot;/&gt; &lt;/web-server&gt; 2.配置/conf/nginx.confserver { listen 80; server_name www.atlassian.com; location /fisheye{ proxy_pass http://localhost:8060/fisheye; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-for $remote_addr; port_in_redirect off; proxy_connect_timeout 300; } } 六、配置jiraServiceDesk请参考 一、配置JIRA","categories":[],"tags":[{"name":"ATLASSIAN产品安装","slug":"ATLASSIAN产品安装","permalink":"http://yoursite.com/tags/ATLASSIAN产品安装/"}]},{"title":"Atlassian产品使用单点登陆-SSO","slug":"Atlassian产品使用单点登陆-SSO","date":"2017-12-13T06:42:37.000Z","updated":"2018-01-15T06:58:50.999Z","comments":true,"path":"2017/12/13/Atlassian产品使用单点登陆-SSO/","link":"","permalink":"http://yoursite.com/2017/12/13/Atlassian产品使用单点登陆-SSO/","excerpt":"","text":"一、配置JIRA1.修改/atlassian-jira/WEB-INF/classes/seraph-config.xml&lt;!--注释以下节点--&gt; &lt;!--&lt;authenticator class=&quot;com.atlassian.jira.security.login.JiraSeraphAuthenticator&quot;/&gt;--&gt; &lt;!--取消注释以下节点--&gt; &lt;authenticator class=&quot;com.atlassian.jira.security.login.SSOSeraphAuthenticator&quot;/&gt; 2.复制/client/conf/crowd.properties到&lt;JIRA-INSTALLATION/atlassian-jira/WEB-INF/classes下.编辑/atlassian-jira/WEB-INF/classes/crowd.properties Key Value application.name jira The application name must match the name that you specified when you defined the application in Crowd (see Step 1 above). application.password The password must match the one that you specified when you defined the application in Crowd (see Step 1 above). crowd.base.url eg. (http://localhost:8095/crowd/)If your Crowd server’s port is configured differently from the default (i.e. 8095), set it accordingly.crowd.base.url must be the same URL used to access Crowd in your Browser. session.validationinterval Set to 0, if you want authentication checks to occur on each request. Otherwise set to the number of minutes between request to validate if the user is logged in or out of the Crowd SSO server. Setting this value to 1 or higher will increase the performance of Crowd’s integration. 以上信息几乎在文件里边都有，只需修改对应的取值即可 二、配置bitbucket添加/shared/bitbucket.properties plugin.auth-crowd.sso.enabled=true 一些可选的参数： key value description plugin.auth-crowd.sso.enabled false Whether SSO support should be enabled or not. Regardless of this setting SSO authentication will only be activated when the system is connected to a Crowd directory that is configured for SSO. plugin.auth-crowd.sso.config.ttl 15 The auth plugin caches the SSO configuration that is retrieved from the remote Crowd server. This setting controls the time to live of that cache.This value is in minutes. plugin.auth-crowd.sso.config.error.wait 1 If an error occurs while retrieving the SSO configuration from the remote Crowd server, the system will wait this long before retrying. The wait time between subsequent attempts is incremented exponentially (1s -&gt; 1.5s -&gt; 2.3s -&gt; 3.4s, etc). The wait time is capped at the configured TTL.This value is in seconds. plugin.auth-crowd.sso.http.max.connections 20 The maximum number of HTTP connections in the connection pool for communication with the Crowd server. plugin.auth-crowd.sso.http.proxy.host The name of the proxy server used to transport SOAP traffic to the Crowd server. plugin.auth-crowd.sso.http.proxy.port The connection port of the proxy server (must be specified if a proxy host is specified). plugin.auth-crowd.sso.http.proxy.username The username used to authenticate with the proxy server (if the proxy server requires authentication). plugin.auth-crowd.sso.http.proxy.password The password used to authenticate with the proxy server (if the proxy server requires authentication). plugin.auth-crowd.sso.http.timeout 5000 The HTTP connection timeout used for communication with the Crowd server. A value of zero indicates that there is no connection timeout.This value is in milliseconds. plugin.auth-crowd.sso.socket.timeout 20000 The socket timeout. You may wish to override the default value if the latency to the Crowd server is high.This value is in milliseconds. plugin.auth-crowd.sso.session.validationinterval 3 The number of minutes to cache authentication validation in the session. If this value is set to 0, each HTTP request will be authenticated with the Crowd server. plugin.auth-crowd.sso.session.lastvalidation atl.crowd.sso.lastvalidation The session key to use when storing a Date value of the user’s last authentication. plugin.auth-crowd.sso.session.tokenkey atl.crowd.sso.tokenkey The session key to use when storing a String value of the user’s authentication token. 三、配置confluence1.修改/confluence/WEB-INF/classes/seraph-config.xml&lt;!--注释以下节点--&gt; &lt;!-- &lt;authenticator class=&quot;com.atlassian.confluence.user.ConfluenceAuthenticator&quot;/&gt; --&gt; &lt;!--取消注释以下节点--&gt; &lt;authenticator class=&quot;com.atlassian.confluence.user.ConfluenceCrowdSSOAuthenticator&quot;/&gt; 2.复制/client/conf/crowd.properties到&lt;CONFLUENCE-INSTALLATION/confluence/WEB-INF/classes下.编辑/confluence/WEB-INF/classes/crowd.properties Key Value application.name confluence The application name must match the name that you specified when you defined the application in Crowd (see Step 1 above). application.password The password must match the one that you specified when you defined the application in Crowd (see Step 1 above). crowd.base.url eg. (http://localhost:8095/crowd/)If your Crowd server’s port is configured differently from the default (i.e. 8095), set it accordingly.crowd.base.url must be the same URL used to access Crowd in your Browser. session.validationinterval Set to 0, if you want authentication checks to occur on each request. Otherwise set to the number of minutes between request to validate if the user is logged in or out of the Crowd SSO server. Setting this value to 1 or higher will increase the performance of Crowd’s integration. 以上信息几乎在文件里边都有，只需修改对应的取值即可 四、配置bamboo1.编辑\\webapp\\WEB-INF\\classes\\seraph-config.xml&lt;!--注释以下节点--&gt; &lt;!--&lt;authenticator class=&quot;com.atlassian.bamboo.user.authentication.BambooAuthenticator&quot;/&gt;--&gt; &lt;!--取消注释以下节点--&gt; &lt;authenticator class=&quot;com.atlassian.crowd.integration.seraph.v25.BambooAuthenticator&quot;/&gt; 五、配置fisheye修改FISHEYE_INST/config.xml &lt;config&gt; ... &lt;security allow-anon=&quot;false&quot; allow-cru-anon=&quot;false&quot;&gt; &lt;built-in&gt; &lt;signup enabled=&quot;true&quot;/&gt; &lt;/built-in&gt; &lt;crowd sso-enabled=&quot;true&quot;/&gt; &lt;admins&gt; &lt;system-admins&gt; &lt;group&gt;confluence-users&lt;/group&gt; &lt;/system-admins&gt; &lt;/admins&gt; &lt;avatar&gt;&lt;disabled/&gt;&lt;/avatar&gt; &lt;emailVisibility/&gt; &lt;/security&gt; ... &lt;/config&gt; //以上内容只需添加&lt;crowd sso-enabled=&quot;true&quot;/&gt; 六、配置jiraServiceDesk请参考 一、配置JIRA","categories":[],"tags":[{"name":"ATLASSIAN产品安装","slug":"ATLASSIAN产品安装","permalink":"http://yoursite.com/tags/ATLASSIAN产品安装/"}]},{"title":"Atlassian产品安装环境准备-数据库(1):MySQL","slug":"Atlassian产品安装环境准备-数据库-1-MySQL","date":"2017-12-11T07:40:18.000Z","updated":"2018-01-15T08:14:13.290Z","comments":true,"path":"2017/12/11/Atlassian产品安装环境准备-数据库-1-MySQL/","link":"","permalink":"http://yoursite.com/2017/12/11/Atlassian产品安装环境准备-数据库-1-MySQL/","excerpt":"","text":"一、JIRA使用MySQL数据库1、 编辑my.cnf 设置default storage engine为InnoDB:[mysqld]…default-storage-engine=INNODB… 确认max_allowed_packet最少为256M:[mysqld]…max_allowed_packet=256M… 确认innodb_log_file_size至少为256M当MySQL的版本是5.5或5.5以下时:[mysqld]…innodb_log_file_size=256M… 确保sql_mode的值不是NO_AUTO_VALUE_ON_ZERO// remove this if it existssql_mode = NO_AUTO_VALUE_ON_ZERO 2、 创建数据库 CREATE DATABASE jiradb CHARACTER SET utf8 COLLATE utf8_bin; 3、 为数据库创建相应的用户MySQL5.5,MySQL 5.6和MySQL 5.7.0到MySQL 5.7.5的语法: GRANT SELECT,INSERT,UPDATE,DELETE,CREATE,DROP,ALTER,INDEX on &lt;JIRADB&gt;.* TO &apos;&lt;USERNAME&gt;&apos;@&apos;&lt;JIRA_SERVER_HOSTNAME&gt;&apos; IDENTIFIED BY &apos;&lt;PASSWORD&gt;&apos;; flush privileges; MySQL5.7.6及以上必须包括REFERENCES的权限: GRANT SELECT,INSERT,UPDATE,DELETE,CREATE,DROP,REFERENCES,ALTER,INDEX on &lt;JIRADB&gt;.* TO &apos;&lt;USERNAME&gt;&apos;@&apos;&lt;JIRA_SERVER_HOSTNAME&gt;&apos; IDENTIFIED BY &apos;&lt;PASSWORD&gt;&apos;; flush privileges; //确认数据库用户权限 SHOW GRANTS FOR &lt;USERNAME&gt;@&lt;JIRA_SERVER_HOSTNAME&gt;; 4、 重启数据库 Windows:使用系统服务管理器重启。 Linux: /etc/init.d/mysqld stop’ 或者 ‘/etc/init.d/mysql stop’ 或者 ‘service mysqld stop’.-启动时将stop换成start.","categories":[],"tags":[{"name":"ATLASSIAN产品安装","slug":"ATLASSIAN产品安装","permalink":"http://yoursite.com/tags/ATLASSIAN产品安装/"}]},{"title":"《Thinking in java》读书笔记(23)","slug":"《Thinking-in-java》读书笔记-23","date":"2017-11-24T05:58:45.000Z","updated":"2018-01-15T06:39:26.554Z","comments":true,"path":"2017/11/24/《Thinking-in-java》读书笔记-23/","link":"","permalink":"http://yoursite.com/2017/11/24/《Thinking-in-java》读书笔记-23/","excerpt":"4.8 switchswitch有时也被划归为一种选择语句。根据证书表达式的值，switch语句可以从一系列代码中选出一段去执行。它的格式如下：123456789switch(integer-selector)&#123; case integral-value1: statement ;break; case integral-value2: statement ;break; case integral-value3: statement ;break; case integral-value4: statement ;break; case integral-value5: statement ;break; //... default:statement;&#125;","text":"4.8 switchswitch有时也被划归为一种选择语句。根据证书表达式的值，switch语句可以从一系列代码中选出一段去执行。它的格式如下：123456789switch(integer-selector)&#123; case integral-value1: statement ;break; case integral-value2: statement ;break; case integral-value3: statement ;break; case integral-value4: statement ;break; case integral-value5: statement ;break; //... default:statement;&#125; 其中integer-selector是选择因子，如果发现和integral-value有相同时，则执行对应的语句，否则执行default。当然我们这里每一个后边都跟一个break，也就是执行完成之后不会执行后边的。如果没有break则会执行后边的代码。例子：123456789101112131415161718192021222324/** * */package demo;/** * * @ClassName testSwitch * @author yaxuSong * @date 2017年11月24日 下午4:32:26 * @Description TODO */public class testSwitch &#123; public static void main(String[] args) &#123; for(;;) &#123; switch (2) &#123; case 1: System.out.println(\"1\"); break; case 2: System.out.println(\"2\"); //break; case 3: System.out.println(\"3\"); //break; default: System.out.println(\"default\"); &#125; &#125; &#125;&#125; 4.9 总结本章就是Java语言编程的一些基础，还有些很少用到的东西，现在也学会了。其他的大概复习了下。好久没写了，希望自己给自己定下来的计划能完成….加油！","categories":[],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/tags/读书笔记/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"《Thinking in java》读书笔记(22)","slug":"《Thinking-in-java》读书笔记-22","date":"2017-11-24T05:58:42.000Z","updated":"2018-01-15T06:39:36.730Z","comments":true,"path":"2017/11/24/《Thinking-in-java》读书笔记-22/","link":"","permalink":"http://yoursite.com/2017/11/24/《Thinking-in-java》读书笔记-22/","excerpt":"4.4 Foreach语法Java SE5引入了一种新的更加简洁的for语法用于数组和容器，也就是foreach语法，表示不必创建int变量去对由访问项构成的序列进行计数，foreach将自动产生每一项。12345678910111213141516package demo;/** * * @ClassName testForeach * @author yaxuSong * @date 2017年11月24日 下午3:01:31 * @Description TODO */public class testForeach &#123; public static void main(String[] args) &#123; for(char c : \"Hello Java!\".toCharArray()) &#123; System.out.println(c); &#125; &#125;&#125;","text":"4.4 Foreach语法Java SE5引入了一种新的更加简洁的for语法用于数组和容器，也就是foreach语法，表示不必创建int变量去对由访问项构成的序列进行计数，foreach将自动产生每一项。12345678910111213141516package demo;/** * * @ClassName testForeach * @author yaxuSong * @date 2017年11月24日 下午3:01:31 * @Description TODO */public class testForeach &#123; public static void main(String[] args) &#123; for(char c : \"Hello Java!\".toCharArray()) &#123; System.out.println(c); &#125; &#125;&#125; 输出： Hello Java! 当然foreach还可以用于任何Iterable对象。 4.5 return在Java中有多个关键词表示无条件分支，它们只是表示这个分支无需任何测试即可发生。这些关键词包括return、break、continue和一种与其他语言中的goto类似的跳转到标号语句的方式。return关键词有两个方面的用途：一方面制定一个方法的返回值（假设它没有void返回值），另一方面它会导致当前方法的退出，并返回那个值。 4.6 break和continue在任何迭代语句的主体部分，都可以break和continue控制循环的流程。其中break用于强行退出循环体，不执行循环剩下的语句。而continue则停止当前的迭代，然后退回循环起始的地方，开始进行下次循环。 其中break可以跳出无穷循环体，无穷循环有两种写法：12while(true)for(;;) 4.7 臭名昭著的goto编程语言一开始就有goto关键字。事实上，goto起源于汇编语言的程序控制：“若条件A成立，则跳到这里；否则跳到那里”。在Java中，标签起作用的唯一地方刚好是在迭代语句之前。在标签和迭代之间置入任何语句都不好。而在迭代之前设置标签的唯一理由是：我们希望在其中嵌套另一个迭代或者开关。这是由于break和continue关键词通常只中断当前循环，但若随同标签一起使用，它们会中断循环，知道标签所在的地方：12345678910111213label1:outer-iteration&#123; inner-iteration&#123; //... break;//(1) //... continue;//(2) //... continue label1;//(3) //... break label1;//(4) &#125;&#125; 在（1）中，break中断内部迭代，回到外部迭代。在（2）中，continue使执行点移回内部迭代的起始处。在（3）中，continue label1同时中断内部迭代以及外部迭代，直接转到label处；随后，它实际上是继续迭代过程，但却从不迭代开始。在（4）中，break label1也会中断所以迭代，并回到label1处，但并不重新进入迭代。也就是说，它实际是完全中止了两个迭代。例子123456789101112131415161718192021222324252627282930/** * */package demo;/** * * @ClassName testBreakContinue * @author yaxuSong * @date 2017年11月24日 下午3:28:06 * @Description TODO */public class testBreakContinue &#123; public static void main(String[] args) &#123; outer: for (int i = 1; i &lt;= 10; i += 2) &#123; inner: for (int j = 0; j &lt;= 10; j += 2) &#123; System.out.println(\"i=\"+i+\" j=\"+j); if(i==5) &#123; continue outer; &#125;// if(j==10)// &#123;// break outer;// &#125; &#125; &#125; &#125;&#125;","categories":[],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/tags/读书笔记/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java工程师成神之路","slug":"Java工程师成神之路","date":"2017-11-24T03:58:56.000Z","updated":"2018-01-15T06:41:14.165Z","comments":true,"path":"2017/11/24/Java工程师成神之路/","link":"","permalink":"http://yoursite.com/2017/11/24/Java工程师成神之路/","excerpt":"","text":"这是我在微信公众号上看到的一篇文章，关于Java学习的一个文章，我觉得写的特别好，所以留下来，作为自己学习的指导. 一、基础篇 1.1 JVM 1.1.1. Java内存模型，Java内存管理，Java堆和栈，垃圾回收http://www.jcp.org/en/jsr/detail?id=133http://ifeve.com/jmm-faq/1.1.2. 了解JVM各种参数及调优 1.1.3. 学习使用Java工具jps, jstack, jmap, jconsole, jinfo, jhat, javap, …http://kenai.com/projects/btracehttp://www.crashub.org/https://github.com/taobao/TProfilerhttps://github.com/CSUG/HouseMDhttp://wiki.cyclopsgroup.org/jmxtermhttps://github.com/jlusdy/TBJMap1.1.4. 学习Java诊断工具http://www.eclipse.org/mat/http://visualvm.java.net/oqlhelp.html1.1.5. 自己编写各种outofmemory，stackoverflow程序HeapOutOfMemoryYoung OutOfMemoryMethodArea OutOfMemoryConstantPool OutOfMemoryDirectMemory OutOfMemoryStack OutOfMemoryStack OverFlow1.1.6. 使用工具尝试解决以下问题，并写下总结当一个Java程序响应很慢时如何查找问题当一个Java程序频繁FullGC时如何解决问题，如何查看垃圾回收日志当一个Java应用发生OutOfMemory时该如何解决，年轻代、年老代、永久代解决办法不同，导致原因也不同1.1.7. 参考资料http://docs.oracle.com/javase/specs/jvms/se7/html/http://www.cs.umd.edu/~pugh/java/memoryModel/http://gee.cs.oswego.edu/dl/jmm/cookbook.html1.2. Java基础知识 1.2.1. 阅读源代码java.lang.Stringjava.lang.Integerjava.lang.Longjava.lang.Enumjava.math.BigDecimaljava.lang.ThreadLocaljava.lang.ClassLoader &amp; java.net.URLClassLoaderjava.util.ArrayList &amp; java.util.LinkedListjava.util.HashMap &amp; java.util.LinkedHashMap &amp; java.util.TreeMapjava.util.HashSet &amp; java.util.LinkedHashSet &amp; java.util.TreeSet1.2.2. 熟悉Java中各种变量类型1.2.3. 熟悉Java String的使用，熟悉String的各种函数1.2.4. 熟悉Java中各种关键字1.2.5. 学会使用List，Map，Stack，Queue，Set上述数据结构的遍历上述数据结构的使用场景Java实现对Array/List排序java.uti.Arrays.sort()java.util.Collections.sort()Java实现对List去重Java实现对List去重，并且需要保留数据原始的出现顺序Java实现最近最少使用cache，用LinkedHashMap1.2.6. Java IO&amp;Java NIO，并学会使用java.io.java.nio.nio和reactor设计模式文件编码，字符集1.2.7. Java反射与javassist反射与工厂模式java.lang.reflect.1.2.8. Java序列化java.io. Serializable什么是序列化，为什么序列化序列化与单例模式google序列化protobuf1.2.9. 虚引用，弱引用，软引用java.lang.ref.实验这些引用的回收1.2.10. 熟悉Java系统属性java.util.Properties1.2.11. 熟悉Annotation用法java.lang.annotation.1.2.12. JMSjavax.jms.1.2.13. JMXjava.lang.management.javax.management.1.2.14. 泛型和继承，泛型和擦除1.2.15. 自动拆箱装箱与字节码1.2.16. 实现Callback1.2.17. java.lang.Void类使用1.2.18. Java Agent，premain函数java.lang.instrument1.2.19. 单元测试Junit，http://junit.org/Jmockit，https://code.google.com/p/jmockit/djUnit，http://works.dgic.co.jp/djunit/1.2.20. Java实现通过正则表达式提取一段文本中的电子邮件，并将@替换为#输出java.lang.util.regex.1.2.21. 学习使用常用的Java工具库commons.lang, commons.…guava-librariesnetty1.2.22. 什么是API&amp;SPIhttp://en.wikipedia.org/wiki/Application_programming_interfacehttp://en.wikipedia.org/wiki/Service_provider_interface1.2.23. 参考资料JDK src.zip 源代码http://openjdk.java.net/http://commons.apache.org/https://code.google.com/p/guava-libraries/http://netty.io/http://stackoverflow.com/questions/2954372/difference-between-spi-and-apihttp://stackoverflow.com/questions/11404230/how-to-implement-the-api-spi-pattern-in-java1.3. Java并发编程 1.3.1. 阅读源代码，并学会使用 java.lang.Threadjava.lang.Runnablejava.util.concurrent.Callablejava.util.concurrent.locks.ReentrantLockjava.util.concurrent.locks.ReentrantReadWriteLockjava.util.concurrent.atomic.Atomic*java.util.concurrent.Semaphorejava.util.concurrent.CountDownLatchjava.util.concurrent.CyclicBarrierjava.util.concurrent.ConcurrentHashMapjava.util.concurrent.Executors1.3.2. 学习使用线程池，自己设计线程池需要注意什么1.3.3. 锁什么是锁，锁的种类有哪些，每种锁有什么特点，适用场景是什么在并发编程中锁的意义是什么1.3.4. synchronized的作用是什么，synchronized和lock1.3.5. sleep和wait1.3.6. wait和notify1.3.7. 写一个死锁的程序1.3.8. 什么是守护线程，守护线程和非守护线程的区别以及用法1.3.9. volatile关键字的理解C++ volatile关键字和Java volatile关键字happens-before语义编译器指令重排和CPU指令重排http://en.wikipedia.org/wiki/Memory_orderinghttp://en.wikipedia.org/wiki/Volatile_variablehttp://preshing.com/20130702/the-happens-before-relation/1.3.10. 以下代码是不是线程安全？为什么？如果为count加上volatile修饰是否能够做到线程安全？你觉得该怎么做是线程安全的？public class Sample {private static int count = 0;public static void increment() {count++;}}1.3.11. 解释一下下面两段代码的差别// 代码1public class Sample {private static int count = 0;synchronized public static void increment() {count++;}} // 代码2public class Sample {private static AtomicInteger count = new AtomicInteger(0);public static void increment() {count.getAndIncrement();}}1.3.12. 参考资料http://book.douban.com/subject/10484692/http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html二、 进阶篇 2.1. Java底层知识 2.1.1. 学习了解字节码、class文件格式http://en.wikipedia.org/wiki/Java_class_filehttp://en.wikipedia.org/wiki/Java_bytecodehttp://en.wikipedia.org/wiki/Java_bytecode_instruction_listingshttp://www.csg.ci.i.u-tokyo.ac.jp/~chiba/javassist/http://asm.ow2.org/2.1.2. 写一个程序要求实现javap的功能（手工完成，不借助ASM等工具）如Java源代码：public static void main(String[] args) {int i = 0;i += 1;i *= 1;System.out.println(i);}编译后读取class文件输出以下代码：public static void main(java.lang.String[]);Code:Stack=2, Locals=2, Args_size=10: iconst_01: istore_12: iinc 1, 15: iload_16: iconst_17: imul8: istore_19: getstatic #2; //Field java/lang/System.out:Ljava/io/PrintStream;12: iload_113: invokevirtual #3; //Method java/io/PrintStream.println:(I)V16: returnLineNumberTable:line 4: 0line 5: 2line 6: 5line 7: 9line 8: 162.1.3. CPU缓存，L1，L2，L3和伪共享http://duartes.org/gustavo/blog/post/intel-cpu-caches/http://mechanical-sympathy.blogspot.com/2011/07/false-sharing.html2.1.4. 什么是尾递归2.1.5. 熟悉位运算用位运算实现加、减、乘、除、取余2.1.6. 参考资料http://book.douban.com/subject/1138768/http://book.douban.com/subject/6522893/http://en.wikipedia.org/wiki/Java_class_filehttp://en.wikipedia.org/wiki/Java_bytecodehttp://en.wikipedia.org/wiki/Java_bytecode_instruction_listings2.2. 设计模式 2.2.1. 实现AOPCGLIB和InvocationHandler的区别http://cglib.sourceforge.net/动态代理模式Javassist实现AOPhttp://www.csg.ci.i.u-tokyo.ac.jp/~chiba/javassist/ASM实现AOPhttp://asm.ow2.org/2.2.2. 使用模板方法设计模式和策略设计模式实现IOC2.2.3. 不用synchronized和lock，实现线程安全的单例模式2.2.4. nio和reactor设计模式2.2.5. 参考资料http://asm.ow2.org/http://cglib.sourceforge.net/http://www.javassist.org/2.3. 网络编程知识2.3.1. Java RMI，Socket，HttpClient2.3.2. 用Java写一个简单的静态文件的HTTP服务器实现客户端缓存功能，支持返回304实现可并发下载一个文件使用线程池处理客户端请求使用nio处理客户端请求支持简单的rewrite规则上述功能在实现的时候需要满足“开闭原则”2.3.3. 了解nginx和apache服务器的特性并搭建一个对应的服务器http://nginx.org/http://httpd.apache.org/2.3.4. 用Java实现FTP、SMTP协议2.3.5. 什么是CDN？如果实现？DNS起到什么作用？搭建一个DNS服务器搭建一个 Squid 或 Apache Traffic Server 服务器http://www.squid-cache.org/http://trafficserver.apache.org/http://en.wikipedia.org/wiki/Domain_Name_System2.3.6. 参考资料http://www.ietf.org/rfc/rfc2616.txthttp://tools.ietf.org/rfc/rfc5321.txthttp://en.wikipedia.org/wiki/Open/closed_principle2.4. 框架知识spring，spring mvc，阅读主要源码ibatis，阅读主要源码用spring和ibatis搭建java server2.5. 应用服务器知识熟悉使用jboss，https://www.jboss.org/overview/熟悉使用tomcat，http://tomcat.apache.org/熟悉使用jetty，http://www.eclipse.org/jetty/三、 高级篇 3.1. 编译原理知识 3.1.1. 用Java实现以下表达式解析并返回结果（语法和Oracle中的select sysdate-1 from dual类似）sysdatesysdate - 1sysdate - 1/24sysdate - 1/(12*2)3.1.2. 实现对一个List通过DSL筛选QList&gt; mapList = new QList&gt;;mapList.add({“name”: “hatter test”});mapList.add({“id”: -1,”name”: “hatter test”});mapList.add({“id”: 0, “name”: “hatter test”});mapList.add({“id”: 1, “name”: “test test”});mapList.add({“id”: 2, “name”: “hatter test”});mapList.add({“id”: 3, “name”: “test hatter”});mapList.query(“id is not null and id &gt; 0 and name like ‘%hatter%’”);要求返回列表中匹配的对象，即最后两个对象； 3.1.3. 用Java实现以下程序（语法和变量作用域处理都和JavaScript类似）：代码：var a = 1;var b = 2;var c = function() {var a = 3;println(a);println(b);};c();println(a);println(b);输出：32123.1.4. 参考资料http://en.wikipedia.org/wiki/Abstract_syntax_treehttps://javacc.java.net/http://www.antlr.org/3.2. 操作系统知识UbuntuCentos使用linux，熟悉shell脚本3.3. 数据存储知识 3.3.1. 关系型数据库MySQL如何看执行计划如何搭建MySQL主备binlog是什么Derby，H2，PostgreSQLSQLite3.3.2. NoSQLCacheRedisMemcachedLeveldbBigtableHBaseCassandraMongodb图数据库neo4j3.3.3. 参考资料http://db-engines.com/en/rankinghttp://redis.io/https://code.google.com/p/leveldb/http://hbase.apache.org/http://cassandra.apache.org/http://www.mongodb.org/http://www.neo4j.org/3.4. 大数据知识 3.4.1. Zookeeper，在linux上部署zk3.4.2. Solr，Lucene，ElasticSearch在linux上部署solr，solrcloud，，新增、删除、查询索引3.4.3. Storm，流式计算，了解Spark，S4在linux上部署storm，用zookeeper做协调，运行storm hello world，local和remote模式运行调试storm topology。3.4.4. Hadoop，离线计算Hdfs：部署NameNode，SecondaryNameNode，DataNode，上传文件、打开文件、更改文件、删除文件MapReduce：部署JobTracker，TaskTracker，编写mr jobHive：部署hive，书写hive sql，得到结果Presto：类hive，不过比hive快，非常值得学习3.4.5. 分布式日志收集flume，kafka，logstash3.4.6. 数据挖掘，mahout3.4.7. 参考资料http://zookeeper.apache.org/https://lucene.apache.org/solr/https://github.com/nathanmarz/storm/wikihttp://hadoop.apache.org/http://prestodb.io/http://flume.apache.org/，http://logstash.net/，http://kafka.apache.org/http://mahout.apache.org/3.5. 网络安全知识 3.5.1. 什么是DES、AES3.5.2. 什么是RSA、DSA3.5.3. 什么是MD5，SHA13.5.4. 什么是SSL、TLS，为什么HTTPS相对比较安全3.5.5. 什么是中间人攻击、如果避免中间人攻击3.5.6. 什么是DOS、DDOS、CC攻击3.5.7. 什么是CSRF攻击3.5.8. 什么是CSS攻击3.5.9. 什么是SQL注入攻击3.5.10. 什么是Hash碰撞拒绝服务攻击3.5.11. 了解并学习下面几种增强安全的技术 http://www.openauthentication.org/HOTP http://www.ietf.org/rfc/rfc4226.txtTOTP http://tools.ietf.org/rfc/rfc6238.txtOCRA http://tools.ietf.org/rfc/rfc6287.txthttp://en.wikipedia.org/wiki/Salt_(cryptography)3.5.12. 用openssl签一个证书部署到apache或nginx3.5.13. 参考资料http://en.wikipedia.org/wiki/Cryptographic_hash_functionhttp://en.wikipedia.org/wiki/Block_cipherhttp://en.wikipedia.org/wiki/Public-key_cryptographyhttp://en.wikipedia.org/wiki/Transport_Layer_Securityhttp://www.openssl.org/https://code.google.com/p/google-authenticator/四、 扩展篇 4.1. 相关知识 4.1.1. 云计算，分布式，高可用，可扩展4.1.2. 虚拟化https://linuxcontainers.org/http://www.linux-kvm.org/page/Main_Pagehttp://www.xenproject.org/https://www.docker.io/4.1.3. 监控http://www.nagios.org/http://ganglia.info/4.1.4. 负载均衡http://www.linuxvirtualserver.org/4.1.5. 学习使用githttps://github.com/https://git.oschina.net/4.1.6. 学习使用mavenhttp://maven.apache.org/4.1.7. 学习使用gradlehttp://www.gradle.org/4.1.8. 学习一个小语种语言GroovyScalaLISP, Common LISP, Schema, ClojureRJuliaLuaRuby4.1.9. 尝试了解编码的本质 了解以下概念ASCII, ISO-8859-1GB2312, GBK, GB18030Unicode, UTF-8不使用 String.getBytes() 等其他工具类/函数完成下面功能 public static void main(String[] args) throws IOException {String str = “Hello, 我们是中国人。”;byte[] utf8Bytes = toUTF8Bytes(str);FileOutputStream fos = new FileOutputStream(“f.txt”);fos.write(utf8Bytes);fos.close();}public static byte[] toUTF8Bytes(String str) {return null; // TODO} 想一下上面的程序能不能写一个转GBK的？写个程序自动判断一个文件是哪种编码4.1.10. 尝试了解时间的本质时区 &amp; 冬令时、夏令时http://en.wikipedia.org/wiki/Time_zoneftp://ftp.iana.org/tz/data/asiahttp://zh.wikipedia.org/wiki/%E4%B8%AD%E5%9C%8B%E6%99%82%E5%8D%80闰年http://en.wikipedia.org/wiki/Leap_year闰秒ftp://ftp.iana.org/tz/data/leapsecondsSystem.currentTimeMillis() 返回的时间是什么4.1.11. 参考资料http://git-scm.com/http://en.wikipedia.org/wiki/UTF-8http://www.iana.org/time-zones4.2. 扩展学习 4.2.1. JavaScript知识4.2.1.1. 什么是prototype修改代码，使程序输出“1 3 5”：http://jsfiddle.net/Ts7Fk/4.2.1.2. 什么是闭包看一下这段代码，并解释一下为什么按Button1时没有alert出“This is button: 1”，如何修改：http://jsfiddle.net/FDPj3/1/4.2.1.3. 了解并学习一个JS框架jQueryExtJSArgularJS4.2.1.4. 写一个Greasemonkey插件 http://en.wikipedia.org/wiki/Greasemonkey4.2.1.5. 学习node.jshttp://nodejs.org/4.2.2. 学习html5ArgularJS，https://docs.angularjs.org/api4.2.3. 参考资料http://www.ecmascript.org/http://jsfiddle.net/http://jsbin.com/http://runjs.cn/http://userscripts.org/五、 推荐书籍《深入Java虚拟机》《深入理解Java虚拟机》《Effective Java》《七周七语言》《七周七数据》《Hadoop技术内幕》《Hbase In Action》《Mahout In Action》《这就是搜索引擎》《Solr In Action》《深入分析Java Web技术内幕》《大型网站技术架构》《高性能MySQL》《算法导论》《计算机程序设计艺术》《代码大全》《JavaScript权威指南》","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"say something to myself","slug":"say-something-to-myself","date":"2017-11-23T09:54:08.000Z","updated":"2018-01-09T09:58:05.814Z","comments":true,"path":"2017/11/23/say-something-to-myself/","link":"","permalink":"http://yoursite.com/2017/11/23/say-something-to-myself/","excerpt":"好久没有写博客了，大概是没有时间，大概是懒吧。在自己看来，时间还是很多的，要看你去做什么事情。 这段时间，自己经历了很多，出去玩了一趟，请了几天的假，然后换了一家公司，在上家公司辞职后，这家公司上班前，发生了很多有趣的事情。","text":"好久没有写博客了，大概是没有时间，大概是懒吧。在自己看来，时间还是很多的，要看你去做什么事情。 这段时间，自己经历了很多，出去玩了一趟，请了几天的假，然后换了一家公司，在上家公司辞职后，这家公司上班前，发生了很多有趣的事情。 NO Thing 1 打了几天游戏，发现自己变成了网民 2 捡了一个iPad,给了网吧老板，老板表扬我给我加了200网费 3 上家公司的一个老板听说我离职，想挖我过去，给我很多，但是工作太累被我拒绝，拒绝的原因其实也有这家公司的原因，现在有时候会后悔，有时候也不会在意这个。 4 去二姐家看孩子，也看见了大姑，她消瘦了很多 5 上班第一天就去了上海出差，每次来上海都下雨，走的时候也下着小雨 这几天突然想起那个女孩，有时候会很想，也许还是没有忘记她，依然喜欢她，但是出于我们的这种关系，我很想联系她，但是不敢联系。想到即使联系了一阵嘘寒问暖之后，也不知该说些什么。 也许人生就是这样，有些东西就是无法触及的。但是我还对此抱有希望吧。","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"怀念那些我喜欢的经典","slug":"怀念那些我喜欢的经典","date":"2017-10-25T09:53:09.000Z","updated":"2018-01-09T09:53:32.001Z","comments":true,"path":"2017/10/25/怀念那些我喜欢的经典/","link":"","permalink":"http://yoursite.com/2017/10/25/怀念那些我喜欢的经典/","excerpt":"","text":"昨晚一时兴起，特别想看之前看过的一部电影，然后就下载了下来，当时已经是1点多了，然后还是禁不住看了起来，还是被故事中的人物和情节所感动。希望自己也能够拥有那样的爱情吧。","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"《Thinking in java》读书笔记(21)","slug":"《Thinking-in-java》读书笔记-21","date":"2017-10-24T05:58:39.000Z","updated":"2018-01-15T06:27:30.168Z","comments":true,"path":"2017/10/24/《Thinking-in-java》读书笔记-21/","link":"","permalink":"http://yoursite.com/2017/10/24/《Thinking-in-java》读书笔记-21/","excerpt":"","text":"第四章 控制执行流程就像有知觉的生物一样，程序必须在执行过程中控制它的世界，并做出选择。在Java中，你要使用执行控制语句来做出选择。Java使用了C的所有流程控制语句，所以如果读者以前用过C或者C++编程，那么应该非常熟悉了，大多数过程编程语言都具有某些形式的控制语句，它们通常在各种语言间是交迭的。在Java中,涉及的关键字包括if-else、while、do-while、for、return、break以及选择语句switch。然而Java并不支持goto. 4.1true和false所有的语句都利用表达式的真假来决定是否执行。在Java中不支持使用数字作为布尔值来使用。虽然在C和C++中是允许的。 4.2if-elseif-else语句是控制程序流程中最基本的形式。其中else是可选的，所以可按下述两种形式来使用if:if(Bollean-expression)statement或if(Bollean-expression)statementelsestatement 其中布尔表达式必须产生布尔值。如下判断数大数小的例子：1234567891011121314151617181920package alljavaexample;/** * * @ClassName IfElse * @author yaxuSong * @date 2017年10月24日 下午3:40:08 * @Description TODO */public class IfElse &#123; public static int test(int num1,int num2) &#123; if(num1&gt;=num2) return num1; else return num2; &#125; public static void main(String[] args) &#123; System.out.println(test(10,5)); System.out.println(test(6,11)); &#125;&#125; output: 1011 4.3迭代while、do-while和for用来控制循环，有时将他们划分为迭代语句（iteration statement）。语句会重复执行，直到起控制作用的布尔表达式（Booleanexperssion）得到“假”的结果为止。while循环到的格式如下：while(Boolean-experssion)statement 4.3.1 do-whiledo-while的格式如下：dostatementwhile(Boolean-experssion);while和do-while语句的区别就是do-while中的语句至少会执行一次。即便第一次表达式的值false，也会先执行一次。 4.3.2 forfor循环可能是最经常使用的迭代形式，这种在第一次迭代之前要进行初始化。随后，它会进行条件测试，而且在每一次迭代结束时，进行某种形式的“步进”，for循环格式如下:for(initialization;Boolean-experssion;step)statement初始化（initialization）表达式、布尔表达式（Boolean-experssion）,或者步进（step）运算，都可以为空。每次迭代前会测试布尔表达式。若为true才会执行。 4.3.3 逗号操作符逗号操作符的作用是用来分隔函数的不同参数。Java中唯一用到逗号操作符的地方就是for循环的控制表达式。在控制表达式的初始化和步进控制部分，可以使用一系列由逗号分隔的语句；而且那些语句会独立执行。123456789101112131415package alljavaexample;/** * * @ClassName CommaOperator * @author yaxuSong * @date 2017年10月24日 下午4:15:57 * @Description TODO */public class CommaOperator &#123; public static void main(String[] args) &#123; for (int i = 1, j = i + 10; i &lt; 5; i++, j = i * 2) &#123; System.out.println(\"i = \" + i + \" j = \" + j); &#125; &#125;&#125; 输出： i = 1 j = 11i = 2 j = 4i = 3 j = 6i = 4 j = 8","categories":[],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/tags/读书笔记/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"国庆快乐","slug":"国庆快乐","date":"2017-10-01T09:52:09.000Z","updated":"2018-01-09T09:52:49.912Z","comments":true,"path":"2017/10/01/国庆快乐/","link":"","permalink":"http://yoursite.com/2017/10/01/国庆快乐/","excerpt":"","text":"国庆快乐，马上就要回家的心情还是很激动的！ 当然也少不了中秋快乐。","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"《Thinking in java》读书笔记(20)","slug":"《Thinking-in-java》读书笔记-20","date":"2017-09-30T05:58:36.000Z","updated":"2018-01-15T06:24:05.762Z","comments":true,"path":"2017/09/30/《Thinking-in-java》读书笔记-20/","link":"","permalink":"http://yoursite.com/2017/09/30/《Thinking-in-java》读书笔记-20/","excerpt":"","text":"3.14使用操作符时常犯的错误使用操作符时一个常犯的错误就是，即使对表达式如何计算结果不确定，也不愿意使用括号。这个问题在Java中仍然存在。在C和C++中，一个特别常见的错误123while(x = y)&#123; //do something&#125; 很明显是“==”而不是“=”，但是因为C和C++的机制，如果y是一个非0值m,这会造成一个死循环。而在java中它期望的是一个boolean结果，而int不会转成boolean，自然会报错的。 3.15 类型转换器操作符类型转换（cast）的原意就是“模型铸造”。在适当得时候，Java会将一种数据类型自动转换成另一种。例如，假设我们为浮点变量赋以一个整数值，编译器会自动将int转为float。类型转换允许我们显式地进行这种类型转换，或者在不能自动进行转换的时候进行强制转换。12int i = 200;long lon= (long)i; 在C和C++中，类型转换有时会让人头痛。但在Java中，类型转换则是一种比较安全的操作。然而，如果执行一种名为窄化转换（narrowing conversion）的操作（也就是说，将能容纳更多信息的数据类型转换成无法 容纳那么多信息的类型），就会可能面临信息丢失的危险。此时编译器会强制我们去进行类型转换。而对于扩展转换（widening conversion）,则不必进行显示转换。Java允许我们把任何基本数据类型转换成别的基本数据类型，布尔类型除外。 3.15.1 截尾和舍入在执行窄化转换时，必须注意截尾与舍入的问题。例如浮点型转整型。29.7转化成int,结果不是30而是29。因为float或者double转为整型时进行的是截尾，如果想要进行舍入需要使用java.lang.Math中的round()方法。 3.15.2 提升如果对基本数据类型执行算术运算或按位运算，大家会发现，只要类型比int小（char、byte、short），那么在运算前，这些值会自动转换成int。最终的结果也是int。如果想把结果赋值给小的类型，就必须使用类型转换。 3.16 Java没有sizeof在C和C++中，sizeof()操作符可以告诉我们数据项分配的字节数。在C和C++中，需要使用sizeof()的最大原因是为了“移植”。不同的数据类型在不同的机器上可能会有不同的大小。Java不需要sizeof()是因为所有数据类型在所有机器的大小都是相同的。我们不必考虑移植问题——————因为它已经被设计在语言中了。 3.17 操作符小结能够对布尔型值进行的运算非常有限。我们只能赋予它true和false值，并测试它为真还是为假，而不能将布尔值相加，或对布尔值进行其它运算。我们要在类型的提升上多多关注。 3.18 总结这一张花了很多时间，主要是自己的时间不是很多，希望自己能在2018年之前看完一半吧。","categories":[],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/tags/读书笔记/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"《Thinking in java》读书笔记(19)","slug":"《Thinking-in-java》读书笔记-19","date":"2017-09-27T05:58:21.000Z","updated":"2018-01-15T06:11:40.302Z","comments":true,"path":"2017/09/27/《Thinking-in-java》读书笔记-19/","link":"","permalink":"http://yoursite.com/2017/09/27/《Thinking-in-java》读书笔记-19/","excerpt":"3.11移位操作符移位操作符只可用来处理整数类型（基本类型的一种）。左移位操作符（&lt;&lt;）能按照操作符右侧指定的位数将操作符左边的操作数向左移动（在低位补0）。“有符号”右移操作符（&gt;&gt;）则按照操作符右侧指定的位数将操作符左边的操作数向右移。“有符号”右移位操作符使用“符号扩展”：若符号为正，则在高位插入0；若符号为负，则在高位插入1。Java中增加一种“无符号”右移位操作符（&gt;&gt;&gt;）,它使用“零扩展”：无论正负，都在高位插入0。这一操作符是C和C++中所没有的。","text":"3.11移位操作符移位操作符只可用来处理整数类型（基本类型的一种）。左移位操作符（&lt;&lt;）能按照操作符右侧指定的位数将操作符左边的操作数向左移动（在低位补0）。“有符号”右移操作符（&gt;&gt;）则按照操作符右侧指定的位数将操作符左边的操作数向右移。“有符号”右移位操作符使用“符号扩展”：若符号为正，则在高位插入0；若符号为负，则在高位插入1。Java中增加一种“无符号”右移位操作符（&gt;&gt;&gt;）,它使用“零扩展”：无论正负，都在高位插入0。这一操作符是C和C++中所没有的。如果对char、byte和short进行移位操作,那么会将它们转换成int类型在进行操作，而且它的结果也是一个int值。只有右端低5位的值有用，因为int最大是32位。若对long操作，其结果也是long值。只会用到右端6位，为了防止超过long的位数。“移位”可与“等号”（&lt;&lt;=或&gt;&gt;=或&gt;&gt;&gt;=）组合使用。有符号的数最高位是符号位：0为正，为负。 3.12三元操作符if-else三元操作符也成为条件操作符，它显得比较特别，因为它有三个操作数，但它确实属于操作符的一种，因为它最终也会生成一个值，这与if-else语句是不同的。其表达式采取下述形式：boolean-exp ? value0:value1如果boolean-exp(布尔表达式)的结果为true，就计算value0,而且这个计算结果也就是操作符最终产生的结果。如果boolean-exp的结果为true,就计算value1,同样，它的结果也就变成了最终的操作符的结果。当然也可以用普通的if-else，但是三元操作符是代码变得更加简洁。尽管C(C中发明了该操作符)引以为傲的就是它是一种简练的语言。它的引入多半是为了高效编程，但是你如果频繁使用，可能会产生极差的可读性代码。12345678910int TernaryIfElse(int i)&#123; return i&lt;10 ? i : 100;&#125;int standardIfElse(int i)&#123; if(i&lt;10) return i; else return 100;&#125; 可以看出两个方法的运算结果是一样的，但是TernaryIfElse显得更加紧凑，而standardIfElse更易于理解。而我们在使用过程中三元表达式也是多用于赋值。 3.13 字符串操作符+和+=这两个操作符在Java中可以是用来连接字符串。这项功能在C++中是一个不错的主意，所以引入了操作符重载（operate overloading）,以便C++程序员可以为几乎所有的操作符增加功能。但是由于C++的一些限制，是的操作符重载变得非常复杂，而且实现起来需要考虑周全。虽然用Java实现起来比较容易，但是我们还是不会想C++和C#程序员那样实现自己的重载操作符。12345String s=\"sss\";int a = 100;int b = 200;System.out.println(a + s + b);// Output:100sss200","categories":[],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/tags/读书笔记/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"《Thinking in java》读书笔记(18)","slug":"《Thinking-in-java》读书笔记-18","date":"2017-09-18T05:58:17.000Z","updated":"2018-01-15T06:39:48.522Z","comments":true,"path":"2017/09/18/《Thinking-in-java》读书笔记-18/","link":"","permalink":"http://yoursite.com/2017/09/18/《Thinking-in-java》读书笔记-18/","excerpt":"3.9直接常量直接常量是的编译器准确的知道要生成什么样的类型，但是有的时候确实模棱两可。发生这种情况，一般情况下我们需要对编译器加以适当的“指导”。 我们可以在常量后边加一些后缀字符标志它的类型。若为大写（或小写）的L，代表Long(但是，是用小写字幕l容易造成混淆，因为它看起来很像数字1)。大写（或小写）字母F，代表float，大写（或小写）字母D，代表double。十六进制则是用前缀0x或（0X），后边跟随0-9或小写（或大写）的a-f来代表。八进制则是以0位前缀，后边跟随0-7的数字。 名称 前缀 后缀 字符 Long L/l 0-9 Double D/d 0-9 Float F/f 0-9 十六进制 0x/0X 0-9,a-f/A-F 八进制 0 0-7","text":"3.9直接常量直接常量是的编译器准确的知道要生成什么样的类型，但是有的时候确实模棱两可。发生这种情况，一般情况下我们需要对编译器加以适当的“指导”。 我们可以在常量后边加一些后缀字符标志它的类型。若为大写（或小写）的L，代表Long(但是，是用小写字幕l容易造成混淆，因为它看起来很像数字1)。大写（或小写）字母F，代表float，大写（或小写）字母D，代表double。十六进制则是用前缀0x或（0X），后边跟随0-9或小写（或大写）的a-f来代表。八进制则是以0位前缀，后边跟随0-7的数字。 名称 前缀 后缀 字符 Long L/l 0-9 Double D/d 0-9 Float F/f 0-9 十六进制 0x/0X 0-9,a-f/A-F 八进制 0 0-7 3.9.1 指数记数法Java采用了一种很不直观的记数法来表示指数。1234float expFloat = 1.39e-43f;expFloat = 1.39E-43f;double expDouble = 47e47d;double expDouble2 = 47e47; 我们知道在科学与工程领域，“e”代表自然对数的技基数，约等于2.718（Java中的Math.E给出了更精确的double值）。这种用法正是C、C++以及Java中都存在的。在Java中看到1.39e-43，表示的是1.39*10（-43）. 3.10 按位操作符按位操作符会对两个参数中对应的位执行布尔代数运算，并最终生成一个结果。对应的规则是： 名称 操作 与(&amp;) 如果两个输入位都是1，则输出1否则输出0 或(丨) 如果两个输入位有一个是1，则输出1否则输出0 异或(^) 如果两个输入位某一个是1，但不全是1，则输出1 非(~) 也成取反操作，属于一元操作符 例子：123456789101112131415161718192021/** * * @ClassName AutoInc * @author yaxuSong * @date 2017年9月11日 下午5:50:18 * @Description TODO */public class AutoInc &#123; public static void main(String[] args) &#123; int front=10; int back=14; int res1=front&amp;back; int res2=front|back; int res3=front^back; int res4=~front; System.out.println(Integer.toBinaryString(front)+\"&amp;\"+Integer.toBinaryString(back)+\"=\"+Integer.toBinaryString(res1)); System.out.println(Integer.toBinaryString(front)+\"|\"+Integer.toBinaryString(back)+\"=\"+Integer.toBinaryString(res2)); System.out.println(Integer.toBinaryString(front)+\"^\"+Integer.toBinaryString(back)+\"=\"+Integer.toBinaryString(res3)); System.out.println(\"~\"+Integer.toBinaryString(front)+\"=\"+Integer.toBinaryString(res4)); &#125;&#125; Output: 1010&amp;1110=10101010|1110=11101010^1110=100~1010=11111111111111111111111111110101 按位操作符也可与等号(=)联合使用，&amp;=、|=、^=都是合法的，而~是一元操作符，不呢个和=连用。我们将布尔类型作为一种单比特值对待，所以我们可以使用按位“与”、按位“或”、按位“异或”。但不能使用按位“非”。对于布尔值，它们与逻辑操作符的结果相同，但是他们不会中途“短路”。虽然存在按位“异或”，但是我们并不能用它来进行“逻辑”操作。例子:1234567891011121314151617181920212223242526272829303132333435/** * * @ClassName compare * @author yaxuSong * @date 2017年9月18日 上午12:18:16 * @Description TODO */public class compare &#123; static boolean t1() &#123; System.out.println(\"t1运行了\"); return false; &#125; static boolean t2() &#123; System.out.println(\"t2运行了\"); return true; &#125; static boolean t3() &#123; System.out.println(\"t3运行了\"); return false; &#125; static boolean t4() &#123; System.out.println(\"t4运行了\"); return true; &#125; public static void main(String[] args) &#123; System.out.println(\"结果:\"+ (t1()&amp;t2())); System.out.println(\"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\"); System.out.println(\"结果:\"+ (t2()|t4())); System.out.println(\"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\"); System.out.println(\"结果:\"+ (t2()&amp;t4())); System.out.println(\"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\"); System.out.println(\"结果:\"+ (t3()|t4())); System.out.println(\"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\"); &#125;&#125; Output t1运行了t2运行了结果:false@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@t2运行了t4运行了结果:true@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@t2运行了t4运行了结果:true@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@t3运行了t4运行了结果:true@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@","categories":[],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/tags/读书笔记/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"《Thinking in java》读书笔记(17)","slug":"《Thinking-in-java》读书笔记-17","date":"2017-09-18T05:54:24.000Z","updated":"2018-01-15T05:56:30.752Z","comments":true,"path":"2017/09/18/《Thinking-in-java》读书笔记-17/","link":"","permalink":"http://yoursite.com/2017/09/18/《Thinking-in-java》读书笔记-17/","excerpt":"","text":"3.8逻辑操作符逻辑操作符“与”（&amp;&amp;）、或（||）、非（！）能根据参数的逻辑关系，生成一个布尔值（true或fasle）。“与”、“或”、“非”操作只能作用于布尔值。与C++不同的的是：不可将一个非布尔值当做布尔值在逻辑表达式中使用。如果在应该使用String值的地方使用布尔值，布尔值会自动转换成适当的文本形式（false或true）。 3.8.1 短路当使用逻辑操作符时，我们会遇到一种“短路”的现象。即一旦能够明确无误的确定整个表达式的值，就不再执行表达式剩下的部分。 ||只要运算第一个值，得到true，就不再计算后边的值。&amp;&amp;只要运算第一个值，得到false,就不再计算后边的值。例子：1234567891011121314151617181920212223242526272829303132333435/** * * @ClassName compare * @author yaxuSong * @date 2017年9月18日 上午12:18:16 * @Description TODO */public class compare &#123; static boolean t1() &#123; System.out.println(\"t1运行了\"); return false; &#125; static boolean t2() &#123; System.out.println(\"t2运行了\"); return true; &#125; static boolean t3() &#123; System.out.println(\"t3运行了\"); return false; &#125; static boolean t4() &#123; System.out.println(\"t4运行了\"); return true; &#125; public static void main(String[] args) &#123; if(t1()&amp;&amp;t2()); System.out.println(\"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\"); if(t2()||t4()); System.out.println(\"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\"); if(t2()&amp;&amp;t4()); System.out.println(\"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\"); if(t3()||t4()); System.out.println(\"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\"); &#125;&#125; Output: t1运行了@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@t2运行了@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@t2运行了t4运行了@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@t3运行了t4运行了@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@","categories":[],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/tags/读书笔记/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"《Thinking in java》读书笔记(16)","slug":"《Thinking-in-java》读书笔记-16","date":"2017-09-11T05:48:53.000Z","updated":"2018-01-15T05:57:30.501Z","comments":true,"path":"2017/09/11/《Thinking-in-java》读书笔记-16/","link":"","permalink":"http://yoursite.com/2017/09/11/《Thinking-in-java》读书笔记-16/","excerpt":"","text":"3.6自动递减和递增和C类似，Java提供了大量的快捷运算，这些快捷运算使编程方便，同时也使得代码更容易阅读，但是有时可能使代码阅读起来更困难。递增和递减算是两种不错的快捷运算（常称为“自动递增”和“自动递减”）。表达式 ++a就等价于a+=1(a为int值);而递增和递减又分为“前缀式”和“后缀式”。对于前缀式递增和递减（++a和–a）是会先执行加加和减减再运算。而后缀式（a++和a–）是先运算再加加和减减。12345678910111213141516171819/** * * @ClassName AutoInc * @author yaxuSong * @date 2017年9月11日 下午5:50:18 * @Description TODO */public class AutoInc &#123; public static void main(String[] args) &#123; int i =1; System.out.println(\"i :\" +i ); System.out.println(\"++i :\" + ++i ); System.out.println(\"i++ :\" + i++ ); System.out.println(\"i :\" +i ); System.out.println(\"--i :\" + --i ); System.out.println(\"i-- :\" + i-- ); System.out.println(\"i :\" +i ); &#125;&#125; Output: i :1++i :2i++ :2i :3–i :2i– :2i :1 从中可以看出，对于前缀形式，我们在执行完运算后才得到值。但是对于后缀形式，则是在运算运算执行之前就得到值。递增操作符真是C++这个名字的一种解释，暗示着“超越C一步”。在早期的一次有关Java的演讲中，Bill Joy（Java创创始人之一）声称“Java=C++–”意味着Java已除去C++中一些困难而又没有必要的东西，成为了一种更精简的语言。 3.7关系操作符关系操作符声称的是一个boolean（布尔）结果，它们计算的是操作数的值之间的关系。如果关系是真实的，关系表达式会生成true(真)，相反，会生成false(假)。关系操作符有：小于(&lt;)、大于(&gt;)、小于或等于、(&lt;=)大于或等于（&gt;=）、等于（==）。等于或者不等于适用于所有的基本数据类型。而其他的不适用于boolean类型。因为boolean值只能为true和false。“大于”和“小于”没有实际意义。 3.7.1测试对象的等价性关系操作符==和!=也适用于所有对象。但这两个操作符通常会使第一次接触Java的程序员赶到迷惑，下面给出一个例子：123456789101112131415/** * * @ClassName Eqivalence * @author yaxuSong * @date 2017年9月17日 下午11:39:44 * @Description TODO */public class Eqivalence &#123; public static void main(String[] args) &#123; Integer n1 = new Integer(47); Integer n2 = new Integer(47); System.out.println(n1==n2); System.out.println(n1!=n2); &#125;&#125; Output: falsetrue 实际上尽管他们的值相同，但是对象的引用却不相同，所以打印false和true。这和C++有所不同。而==和!=比较的就是对象引用。这时如果我们相比较大小，可以使用所有对象都适用的equals()方法。但这个却不适用于基本类型，基本类型可以直接使用==和!=即可。如下两个例子：1234567891011121314/** * * @ClassName Eqivalence * @author yaxuSong * @date 2017年9月17日 下午11:39:44 * @Description TODO */public class Eqivalence &#123; public static void main(String[] args) &#123; Integer n1 = new Integer(47); Integer n2 = new Integer(47); System.out.println(n1.equals(n2)); &#125;&#125; 输出是true。我们验证了我们的说法。第二个例子：123456789101112131415161718/** * * @ClassName Eqivalence * @author yaxuSong * @date 2017年9月17日 下午11:39:44 * @Description TODO */class Value&#123; int i;&#125;public class Eqivalence &#123; public static void main(String[] args) &#123; Value v1 = new Value(); Value v2 = new Value(); v1.i=v2.i=100; System.out.println(v1.equals(v2)); &#125;&#125; 结果是false。这次的结果是不是很费解？这是由于equals()方法默认行为是引用比较。所以自己除非在新的类中覆盖equals()方法，否则不可能表现出我们所希望的行为结果。下面给出一个重写equals()方法的例子：1234567891011121314151617181920212223242526/** * * @ClassName Eqivalence * @author yaxuSong * @date 2017年9月17日 下午11:39:44 * @Description TODO */class Value&#123; int i; @Override public boolean equals(Object obj) &#123; if(obj instanceof Value &amp;&amp; ((Value) obj).i==this.i) return true; else return false; &#125; &#125;public class Eqivalence &#123; public static void main(String[] args) &#123; Value v1 = new Value(); Value v2 = new Value(); v1.i=v2.i=1; System.out.println(v1.equals(v2)); &#125;&#125;","categories":[],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/tags/读书笔记/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"回忆总是会使我泪流满面","slug":"回忆总是会使我泪流满面","date":"2017-09-05T09:46:42.000Z","updated":"2018-01-09T09:48:59.825Z","comments":true,"path":"2017/09/05/回忆总是会使我泪流满面/","link":"","permalink":"http://yoursite.com/2017/09/05/回忆总是会使我泪流满面/","excerpt":"","text":"今天想起一些东西，让我很难受。","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"迷茫","slug":"迷茫","date":"2017-09-01T09:45:56.000Z","updated":"2018-01-09T09:46:25.465Z","comments":true,"path":"2017/09/01/迷茫/","link":"","permalink":"http://yoursite.com/2017/09/01/迷茫/","excerpt":"","text":"刚刚加入了新的部门，对自己的前途有点堪忧。有点迷茫。 不过我相信自己,所有的还是要靠自己。所以不管怎样都要加油！","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"一个人的情人节","slug":"一个人的情人节","date":"2017-08-28T09:42:15.000Z","updated":"2018-01-09T09:45:37.878Z","comments":true,"path":"2017/08/28/一个人的情人节/","link":"","permalink":"http://yoursite.com/2017/08/28/一个人的情人节/","excerpt":"\\ \\ / / | | | | () ( ) | | / | \\ \\ / / | | __ | | _|/ _ | | | | _ \\ \\/ // ` || | / | ‘ \\ | __|| || ‘ \\ / \\ / __| / | / _ || | | | | |/ \\ | ‘| / \\ | ‘ \\ / \\ | ‘ \\ / _ | ‘|/ | / \\ | ‘ \\ \\ /| (_| || || /| | | || | | || | | || / \\ \\ | (| || (| || || | | | | () || | | () || | | || / | |_) || /| | _ | () || | | | \\/ _,||| __||| || _||||| || _| |_/ _,| _,| _, | || _/ || \\/ || || _| | ./ _||| |/ _/ || || / | | | |__/ ||","text":"\\ \\ / / | | | | () ( ) | | / | \\ \\ / / | | __ | | _|/ _ | | | | _ \\ \\/ // ` || | / | ‘ \\ | __|| || ‘ \\ / \\ / __| / | / _ || | | | | |/ \\ | ‘| / \\ | ‘ \\ / \\ | ‘ \\ / _ | ‘|/ | / \\ | ‘ \\ \\ /| (_| || || /| | | || | | || | | || / \\ \\ | (| || (| || || | | | | () || | | () || | | || / | |_) || /| | _ | () || | | | \\/ _,||| __||| || _||||| || _| |_/ _,| _,| _, | || _/ || \\/ || || _| | ./ _||| |/ _/ || || / | | | |__/ ||一年七夕到，没想到是一个人过。不知道下一次的2.14，下一次的七夕，会不会有一个人来到我的身旁。 .-./) .–. .–. __ .-./) ,———. ,—–. ,—. ,—. ..–’\\ .-.’) | | | | .’ . \\ .-.&#39;)\\ \\ \\ \\ / /.&#39; .-, &#39;. .&#39; | | | | \\ / | \\ \\ / /| |/-‘ \\ | ( ) | |/ ‘ \\ \\/ -&#39; \\–. ,—‘ \\ . / ‘/ ,-.| \\ \\ | .’ | | | , \\/ , | \\ . / ‘ | .-‘ ‘ -&#39;“|( o ) | ||_| / |-‘&quot; | \\ ( ) .’; \\ ‘ / | :.’ ‘ | | | | /| | ( ) .’ |.-‘.’ / .—. | (,) \\ | | .-| .—. :&lt;/em&gt; &lt;em&gt;: __&lt;/em&gt;(&lt;em&gt; o &lt;/em&gt;)’ | &lt;em&gt;,/ \\ / |’ ( .-.| | ( )/ | | ( o )’ / / | | | |/ | |.’ | | | (I) | |(,)’ : ( ‘/ \\ ;’ (. /| | ( o ) | || |(,)’ .’.( ) | | | ‘ /\\ || ( ) | | | ((=)) |-‘ / \\ &quot;/ \\ ) / | ( () ) | (,) | ||-‘ / .’ (‘o.) | | | / \\ |\\ ( o ) / | | (I) \\ / ‘. /&quot;.&#39; \\ / . \\ / | | | | \\ / | (,)| &#39;—&#39; ---&amp;#39;—&amp;#39;.(_,_).&amp;#39; &amp;#39;---&amp;#39; &amp;#39;---&amp;#39;-..-&#39; &#39;—–&#39;-‘-&#39;&#39; &#39;–&#39; &#39;–&#39;-..-‘ |___|","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"没有什么事情是办不到的，只怕你没法战胜自己","slug":"没有什么事情是办不到的，只怕你没法战胜自己","date":"2017-08-23T09:41:17.000Z","updated":"2018-01-09T09:42:02.021Z","comments":true,"path":"2017/08/23/没有什么事情是办不到的，只怕你没法战胜自己/","link":"","permalink":"http://yoursite.com/2017/08/23/没有什么事情是办不到的，只怕你没法战胜自己/","excerpt":"没有什么是办不到的，就怕就走是自己退缩了。 这几天自己做了很多东西，在业务上和企业开发上有了新的进展。第一次写开源的东西，查看文档，然后自己搞出来，虽然以前都弄过，不过这是第一次在很快的时间内搞出来。第一次和别人一起对接一个业务，分析相关问题可能出现的情况。最后完成任务。解决BUG。","text":"没有什么是办不到的，就怕就走是自己退缩了。 这几天自己做了很多东西，在业务上和企业开发上有了新的进展。第一次写开源的东西，查看文档，然后自己搞出来，虽然以前都弄过，不过这是第一次在很快的时间内搞出来。第一次和别人一起对接一个业务，分析相关问题可能出现的情况。最后完成任务。解决BUG。有时候自己还是退缩的，但是发现你自己的强大远比自己想想的好的多。还是出现什么问题要敢于说出去，要主动去做。这样才行。 过几天就是七夕了，第一次一个人过七夕，然后给自己买了2个皮肤….就算是过了吧。 说起来皮肤的效果还是很不错的。 还有就是自己一定要在过年之前看完这个本书的一半，一定要完成这个任务，加油。","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"感觉最近有点霉运","slug":"感觉最近有点霉运","date":"2017-08-07T09:40:15.000Z","updated":"2018-01-09T09:40:54.520Z","comments":true,"path":"2017/08/07/感觉最近有点霉运/","link":"","permalink":"http://yoursite.com/2017/08/07/感觉最近有点霉运/","excerpt":"感觉最近有点霉运啊…… 很难受啊，最近有点不顺，总是发生不该发生的事情，真的不知道怎么了，看来自己要多多注意了。","text":"感觉最近有点霉运啊…… 很难受啊，最近有点不顺，总是发生不该发生的事情，真的不知道怎么了，看来自己要多多注意了。不要再继续了啊。","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"确实感觉还是有点小累的","slug":"确实感觉还是有点小累的","date":"2017-08-04T09:39:29.000Z","updated":"2018-01-09T09:40:01.721Z","comments":true,"path":"2017/08/04/确实感觉还是有点小累的/","link":"","permalink":"http://yoursite.com/2017/08/04/确实感觉还是有点小累的/","excerpt":"之前记得不知道是谁和我说过，我们这个职业很好，他们每天很累，然后我们整天坐在办公室里边，风吹不到，雨淋不到，日晒不到。薪水还高。但是想想，这种工作也不一定是那种不累的工作。难道你对累不累的评论标准就是这几样嘛？","text":"之前记得不知道是谁和我说过，我们这个职业很好，他们每天很累，然后我们整天坐在办公室里边，风吹不到，雨淋不到，日晒不到。薪水还高。但是想想，这种工作也不一定是那种不累的工作。难道你对累不累的评论标准就是这几样嘛？每天坐在办公室里，不怕太阳☀晒，不怕大雨淋，不怕风吹，好像很好的样子，起始也有很多弊端，每天也是早期晚归，不一定比你们上班晚，下班早，而且大多数的情况还是加班多吧。每天8点起，12点睡？也许要比这个辛苦的多。坐在椅子上一直不动。累的脖子难受，背也酸疼，腰也难受……眼睛也承受不了。最多的感觉是比较饿……想的事情和多，事情的逻辑也比较复杂。","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"难受","slug":"难受","date":"2017-08-01T09:38:38.000Z","updated":"2018-01-09T09:39:14.128Z","comments":true,"path":"2017/08/01/难受/","link":"","permalink":"http://yoursite.com/2017/08/01/难受/","excerpt":"难受啊，我的阿寞永远离我而去了。想到故事的结局，没想到故事的情节。","text":"难受啊，我的阿寞永远离我而去了。想到故事的结局，没想到故事的情节。昨晚要睡觉的时候突然发现这个电视剧怎么更新了？不是每周二凌晨么？哎，不得不为了看到新的剧情而熬夜了，突然发现说好的60集，缩水到54集了，很气啊。本打算能看很久，没想到这样就快要结束了。为什么电视剧总是那种不完美的结局？虽然故事的结尾是有点不开心，但是杜宇故事里边的人物来说算是圆满了。对于我来说，故事里边男女主人公在一起的时间真的是太少了。我还是想她们在一起的时间多一点。","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"《Thinking in java》读书笔记(15)","slug":"《Thinking-in-java》读书笔记-15","date":"2017-08-01T05:43:04.000Z","updated":"2018-01-15T05:46:09.225Z","comments":true,"path":"2017/08/01/《Thinking-in-java》读书笔记-15/","link":"","permalink":"http://yoursite.com/2017/08/01/《Thinking-in-java》读书笔记-15/","excerpt":"","text":"第三章 操作符3.5算术操作符Java的基本算数操作符与其他大多数的程序设计语言时相同的。其中有：+、-、/、*、%。整数除法会直接去掉结果的小数位，而不是四舍五入的结果。Java也使用一种来自C和C++的简化符号同时进行运算与赋值的操作。这要操作符后边紧跟一个等号来表示。如：X+=4。 下面这个例子展示了各种算术操作符的用法:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import java.util.*;/** * * @ClassName MathOps * @author yaxuSong * */public class MathOps &#123; public static void main(String args[]) &#123; // Create a seeded random number generator: Random rand = new Random(47); int i, j, k; // Choose a value from 1 to 100: j = rand.nextInt(100) + 1; System.out.println(\"j : \" + j); k = rand.nextInt(100) + 1; System.out.println(\"k : \" + k); i = j + k; System.out.println(\"j + k : \" + i); i = j - k; System.out.println(\"j - k : \" + i); i = k / j; System.out.println(\"j / k : \" + i); i = k * j; System.out.println(\"j * k : \" + i); i = k % j; System.out.println(\"j % k : \" + i); j %= k; System.out.println(\"j %= k : \" + j); // Floating-point number tests: float u, v, w; // Applies to doubles, too v = rand.nextFloat(); System.out.println(\"v : \" + v); w = rand.nextFloat(); System.out.println(\"w : \" + w); u = v + w; System.out.println(\"v + w : \" + u); u = v - w; System.out.println(\"v - w : \" + u); u = v * w; System.out.println(\"v * w : \" + u); u = v / w; System.out.println(\"v / w : \" + u); u += v; System.out.println(\"u += v : \" + u); u -= v; System.out.println(\"u -= v : \" + u); u *= v; System.out.println(\"u *= v : \" + u); u /= v; System.out.println(\"u /= v : \" + u); &#125;&#125; 程序输出Output： j : 59k : 56j + k : 115j - k : 3j / k : 0j k : 3304j % k : 56j %= k : 3v : 0.5309454w : 0.0534122v + w : 0.5843576v - w : 0.47753322v w : 0.028358962v / w : 9.940527u += v : 10.471473u -= v : 9.940527u *= v : 5.2778773u /= v : 9.940527 要生成数字，程序首先会创建一个Random类的对象。如果在创建过程中没有传递任何参数，那么Java就会将当前时间作为随机数生产器的种子，并由此程序每一次执行都产生不同的结果。（用于随机数生成器的初始化值，随机数生产器对于特定的种子值总是产生相同的随机数序列。） 3.5.1一元加、减操作符一元加号(+)和减号(-)与二元减号加号用相同的符号。如1x = -a; 一元减号用于转变数据的符号，而一元加号只是为了与一元减号想对应，但是它唯一的作用仅仅是将较小的类型的操作数提升为int.","categories":[],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/tags/读书笔记/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"感觉慢慢的步入正轨了","slug":"感觉慢慢的步入正轨了","date":"2017-07-31T09:34:55.000Z","updated":"2018-01-09T09:36:57.038Z","comments":true,"path":"2017/07/31/感觉慢慢的步入正轨了/","link":"","permalink":"http://yoursite.com/2017/07/31/感觉慢慢的步入正轨了/","excerpt":"感觉慢慢的一切都步入正轨了，什么事情都急不得，慢慢来，但是也不能怠慢。","text":"感觉慢慢的一切都步入正轨了，什么事情都急不得，慢慢来，但是也不能怠慢。 有时候觉得自己也并不是那么聪明，有时候觉得自己在这方面还是有一定的天赋的。也许是错觉吧。我是说并不那么聪明是错觉~公司的业务逻辑很复杂，很多东西都需要学习，无论是业务逻辑还是那漫无边际的技术海洋。不过还是静下心来听一首歌比较重要吧。不是么?","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"每次写标题都很困难啊","slug":"每次写标题都很困难啊","date":"2017-07-24T09:34:15.000Z","updated":"2018-01-09T09:38:05.804Z","comments":true,"path":"2017/07/24/每次写标题都很困难啊/","link":"","permalink":"http://yoursite.com/2017/07/24/每次写标题都很困难啊/","excerpt":"最近比忙啊，终于把最近最重要的事情做完了，很开心，接下来应该就没有什么事情分心了。还有些事情，很难受，慢慢来吧，在新公司一切都好。","text":"最近比忙啊，终于把最近最重要的事情做完了，很开心，接下来应该就没有什么事情分心了。还有些事情，很难受，慢慢来吧，在新公司一切都好。最好能尽快的加入到项目的开发中来才好。今天晚点下班哦。新电脑回来了，用的很好，颜值很高。但是很不开心的就是win10的MD编辑器很难用啊。原来的用不了了。","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"2017.07.18记","slug":"2017-07-18记","date":"2017-07-18T09:33:32.000Z","updated":"2018-01-09T09:33:59.593Z","comments":true,"path":"2017/07/18/2017-07-18记/","link":"","permalink":"http://yoursite.com/2017/07/18/2017-07-18记/","excerpt":"","text":"今天算是经过一次练习，算是对这个项目有了一定了解了。","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"《Thinking in java》读书笔记(14)","slug":"《Thinking-in-java》读书笔记-14","date":"2017-07-14T05:36:04.000Z","updated":"2018-01-15T05:41:18.681Z","comments":true,"path":"2017/07/14/《Thinking-in-java》读书笔记-14/","link":"","permalink":"http://yoursite.com/2017/07/14/《Thinking-in-java》读书笔记-14/","excerpt":"第三章 操作符3.4赋值赋值使用操作符“=”，它的意思是将右边的值，赋值给左边。1a = 4; 对基本对象的赋值是简单的，基本类型存储了实际的值，而并非指向一个对象的引用。如a=b，那么b的值就给了a，但是修改a之后，b不受影响。","text":"第三章 操作符3.4赋值赋值使用操作符“=”，它的意思是将右边的值，赋值给左边。1a = 4; 对基本对象的赋值是简单的，基本类型存储了实际的值，而并非指向一个对象的引用。如a=b，那么b的值就给了a，但是修改a之后，b不受影响。对一个对象进行操作时，我们真正操作的是对对象的引用。所以倘若“将一个对象赋值给另一个对象”，实际是将“引用”从一个地方复制到另一个地方。这意味着假若对对象使用c=d,那么c和d都指向原本只有d指向的那个对象。下边是一个例子：1234567891011121314151617181920class Tank&#123; int level;&#125;public class Assignment &#123; public static void main(String args[])&#123; Tank t1 = new Tank(); Tank t2 = new Tank(); t1.level=9; t2.level=47; System.out.println(\"1: t1.level: \" + t1.level+ \", t2.level: \" + t2.level); t1=t2; System.out.println(\"2: t1.level: \" + t1.level+ \", t2.level: \" + t2.level); t1.level=27; System.out.println(\"3: t1.level: \" + t1.level+ \", t2.level: \" + t2.level); &#125;&#125; 程序输出Output: 1: t1.level: 9, t2.level: 472: t1.level: 47, t2.level: 473: t1.level: 27, t2.level: 27 原本t1包含的对对象的引用，是指向一个值为9的对象。在对t1赋值的时候，这个引用被覆盖，也就是丢失了，而那个不再被引用的对象由“垃圾回收器”自动清理。这种特殊的现象通常称作“别名现象”，是Java操作对象的基本方式。在这个例子中，如果想避免别名问题应该怎么办呢？可以这样写：1t1.level = t2.level; 3.4.1方法调用中的别名问题将一个对象传递给方法时，也会产生别名问题：123456789101112131415class Letter&#123; char c;&#125;public class PassObject&#123; static void f(Letter y)&#123; y.c='z'; &#125; public static void main(String[] args)&#123; Letter x = new Letter(); x.c = 'a'; System.out.println(\"1: x.c:\" + x.c); f(x); System.out.println(\"2: x.c:\" + x.c); &#125;&#125; 程序输出Output: 1: x.c:a 2: x.c:z","categories":[],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/tags/读书笔记/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"停更ThinKing in Java的读书笔记","slug":"停更ThinKing-in-Java的读书笔记","date":"2017-07-11T02:06:07.000Z","updated":"2018-01-11T02:10:56.563Z","comments":true,"path":"2017/07/11/停更ThinKing-in-Java的读书笔记/","link":"","permalink":"http://yoursite.com/2017/07/11/停更ThinKing-in-Java的读书笔记/","excerpt":"","text":"停止更新ThinKing in Java的读书笔记了，因为刚刚入职新公司，有很多东西都需要学习，所以停止了Thinking in Java的阅读。但是等这一阵子过去，这本书是我第一本需要读完的书。 刚刚加入了新公司，一开始害怕会有些不适应，但是第二天就觉得自己慢慢的融入进来了。公司很不错。但是也有对CSDN的怀念，哪里的人都很好。如果之前有机会留在那里的话，自己也肯定选择留在那。新公司的项目还没有入手，但是希望自己能够尽快的投入到工作中去。比较开心的就是，自己买了一个新电脑花了很多钱。也算是对工作的投入吧。不过电脑还没有收到呢，好期待啊。 越努力，越幸运。 ----------送给自己","categories":[],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/tags/读书笔记/"}]},{"title":"做决定看似简单其实很难","slug":"做决定看似简单其实很难","date":"2017-07-05T09:31:36.000Z","updated":"2018-01-09T09:32:55.053Z","comments":true,"path":"2017/07/05/做决定看似简单其实很难/","link":"","permalink":"http://yoursite.com/2017/07/05/做决定看似简单其实很难/","excerpt":"无论做出怎样的选择,路都需要自己走。","text":"无论做出怎样的选择,路都需要自己走。 出差了一周，好久没看书了，所以读书笔记也搁置了。所以今晚打算写一篇读书笔记。现在也算是到了关键的时候了，下周可能就要去新公司上班，面临新的同事，新的环境，希望自己能够习惯，能够相处的比较好。 可能我最终还是没能留下来。主要是因为自己不是那种栋梁之才吧。我相信如果公司真的想留下我。可能不在乎一个月的工资吧。所以说，我还没有达到那种地步。然而谁也不敢给我保证月底会有机会。这是唯一可悲的吧。我相信你们很想留我，但是这个时间真是不巧，然后你们也不想让我没有了offer。我自己也担心再也没有这样的机会。 不过我还是相信，有缘总会再见的。","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"《Thinking-in-java》读书笔记(13)","slug":"《Thinking-in-java》读书笔记-13","date":"2017-06-23T02:01:36.000Z","updated":"2018-01-15T02:03:47.652Z","comments":true,"path":"2017/06/23/《Thinking-in-java》读书笔记-13/","link":"","permalink":"http://yoursite.com/2017/06/23/《Thinking-in-java》读书笔记-13/","excerpt":"第三章 操作符在最底层，Java中的数据是通过使用操作符来操做的。Java是建立在C++基础之上的，所哟C和C++程序员应该非常熟悉Java的大多数操作符。当然，Java也做了一些改进与简化。 3.1更简单的打印语句前一章中，我们介绍了Java的打印句：1System.out.println(\"Rather a lot of type\");","text":"第三章 操作符在最底层，Java中的数据是通过使用操作符来操做的。Java是建立在C++基础之上的，所哟C和C++程序员应该非常熟悉Java的大多数操作符。当然，Java也做了一些改进与简化。 3.1更简单的打印语句前一章中，我们介绍了Java的打印句：1System.out.println(\"Rather a lot of type\"); 可以看到，这天语句设计很多类型，而且读起来也非常费劲。在第六章中将介绍静态导入（static import）这个在Java SE5中新增加的概念。我自己创建了一个新的类，然后实现简单的打印语句。123456package util;public class MyUtil &#123; public static void print(Object o)&#123; System.out.println(o.toString()); &#125;&#125; 实现部分：123456789101112131415161718package test;import static util.MyUtil.*;import java.util.Date;//: object/Documentation1.java/** A class comment */public class Test &#123; /** A filed comment */ public int i; /** A method comment * @param args * @author songyx * * */ public static void main(String[] args)&#123; print(new Date()); &#125;&#125;///:~ 3.2使用Java操作符操作符接受一个或者多个参数，并生成一个新值。操作符作用域操作数，生成一个新值。几乎所有操作符都只能操作“基本类型”。例外的操作符是“=”、“==”和“！=”。除此之外，String类支持“+”和“+=”。 3.3优先级当一个表达式中存在多个操作符时，操作符的优先级就决定了各部分的计算顺序。Java对计算顺序租了特别的规定。其中最简单的就是先乘除后加减，程序员经常会忘记它们优先级规则，所以应该用括号明确规定计算顺序。1234567891011public class Precedence&#123; publi static void main(String[] args)&#123; int x = 1,y = 2,z = 3; int a = x+ y-2/2 + z; int b = x+ (y-2)/(y+z); System.out.println(\"a=\"+ a +\"b=\"+b); &#125; /* * a=5 b=1 */&#125; 这两个语句看起来大体相同，但是输出结果却不同，这正是括号的作用。","categories":[],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/tags/读书笔记/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"《Thinking in java》读书笔记(12)","slug":"《Thinking-in-java》读书笔记-12","date":"2017-06-22T03:48:41.000Z","updated":"2018-01-15T05:37:12.307Z","comments":true,"path":"2017/06/22/《Thinking-in-java》读书笔记-12/","link":"","permalink":"http://yoursite.com/2017/06/22/《Thinking-in-java》读书笔记-12/","excerpt":"2.10总结花了不算多的时间吧第二章看完了，毕竟自己有一定的基础，所以这些东西看的比较快，有些东西自己之前确实没有注意过，不过通过学习这一章，自己了解了很多更加基础的东西，希望自己再接再厉吧。加油把这本书看完了，然后去看别的书，这本书是我第一本看的这么详细的书。最近工作的事情总算有了眉目，觉得还是小有收获吧。挺开心的，然后昨天是自己的生日，自己竟然不记得了。。。。还在高兴地看自己昨天刚到的新书。算是过了一个生日吧。","text":"2.10总结花了不算多的时间吧第二章看完了，毕竟自己有一定的基础，所以这些东西看的比较快，有些东西自己之前确实没有注意过，不过通过学习这一章，自己了解了很多更加基础的东西，希望自己再接再厉吧。加油把这本书看完了，然后去看别的书，这本书是我第一本看的这么详细的书。最近工作的事情总算有了眉目，觉得还是小有收获吧。挺开心的，然后昨天是自己的生日，自己竟然不记得了。。。。还在高兴地看自己昨天刚到的新书。算是过了一个生日吧。不过多亏你的提醒，让我想起昨天是我的生日。谢谢你。","categories":[],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/tags/读书笔记/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"《Thinking in java》读书笔记(11)","slug":"《Thinking-in-java》读书笔记-11","date":"2017-06-22T03:27:28.000Z","updated":"2018-01-15T05:37:01.697Z","comments":true,"path":"2017/06/22/《Thinking-in-java》读书笔记-11/","link":"","permalink":"http://yoursite.com/2017/06/22/《Thinking-in-java》读书笔记-11/","excerpt":"第二章 一切都是对象2.7你的第一个Java程序最后，让我们编写第一个完整的程序。12345678// HelloDate.javaimport java.util.*;public class HelloDate&#123; public static void main(String[] args)&#123; System.out.println(\"Hello, it's: \"); System.out.println(new Date()); &#125;&#125;","text":"第二章 一切都是对象2.7你的第一个Java程序最后，让我们编写第一个完整的程序。12345678// HelloDate.javaimport java.util.*;public class HelloDate&#123; public static void main(String[] args)&#123; System.out.println(\"Hello, it's: \"); System.out.println(new Date()); &#125;&#125; 在每个程序文件的开头，必须声明import语句，以便引入在文件代码中需要用到的额外类。我们可以看到System类有很多属性，我们选择out,就会发现它是一个静态PrintStream对象。因为是静态的，所以不需要创建任何对象，就可以直接使用。还有一个我们需要注意，就是类名和文件名要相同。main()方法的参数是一个String对象的数组，在这个程序中并未用到args，但是Java编译器要求必须这样做，因为args要用来存储命令行参数。System有很多其他的方法。123456789//: object/ShowProperties.javapublic class ShowProperties&#123; public static void main(String[] args) &#123; System.getProperties.list(System.out); System.out.println(System.getProperty(\"user.name\")); System.out.println(System.getProperty(\"java.library.path\")); &#125;&#125; ///:~ main()的第一行将显示从运行程序的系统中获取的所有“属性”，因此它可以向你提供环境信息。list()方法将结果发送给它的参数：System.out。 2.7.1 编译和运行要编译和运行程序，首先得需要一个Java的开发环境。我们可以登录到Oracle的官网下载与自己机器平台相兼容的JDK。可以通过1javac HelloDate.java 进行编译，正常情况下么不会产生任何响应，如果有任何错误消息返回给你，就说明你可能没有正确安装JDK，或者你的代码有问题。编译成功后，可以通过1java HelloDate 来运行编译成功的程序。可以看到当天的日期被输出。 2.8 注释和嵌入式文档Java有两种注释风格。第一种：传统的C语言风格的注释，C++也继承了这种风格，以“/”开始，随后是注释内容，可以跨越多行，最后以“/”结束。许多程序员在连续的注释内容的第一行都以“*”开头，所以经常看到以下写法。1234/* This is a comment * that continues * across lines */ 但是和以下这种方式没有区别。1234/* This is a comment that continues across lines*/ 第二种风格也是源于C++。这种注释是“单行注释”，以“//”起头。直到句末。1// This is a one-line commnet 2.8.1注释文档代码文档撰写的最大问题，大概就是对文档的维护了。如果代码和文档是分离的，那么在每次修改代码时，都需要修改相应的文档。那么java帮助你把代码和文档放在一个文件内，方便修改。javadoc便是用于提取代码文件中的注释的工具，它是JDK安装的一部分。javadoc输出的是一个HTML文件，可以使用WEB浏览器查看。 2.8.2语法所有javadoc命令都只能在“/”注释中出现，和通常一样，注释结束于“/”。使用javadoc的方式主要有两种：嵌入HTML，或使用“文档标签”。*独立文档标签是一些以“@”字符开头的命令，且要置于注释行的最前面。而“行内文档标签”则可以出现在javadoc的任何地方。它们也是以“@”开头，但要在花括号内。共有三种类型的注释文档，分别对应注释位置后面的三种元素：类、域和方法。123456789101112//: object/Documentation1.java/** A class comment */public class Documentation1 &#123; /** A filed comment */ public int i; /** A method comment */ public static void main(String[] args)&#123; System.getProperties().list(System.out); System.out.println(System.getProperty(\"user.name\")); System.out.println(System.getProperty(\"java.library.path\")); &#125;&#125;///:~ 注意，javadoc只能为public（公共）和protected（受保护）成员进行文档注释。private(私有)和包内可访问成员的注释会被忽落掉。不过可以通过用-private进行标记，一边输出private成员的注释。 2.8.3嵌入式HTMLjavadoc通过生产的HTML文档传送HTML命令，这使你能够充分利用HTML。当然，主要目的还是为了对代码进行格式化。1234567//: obejct/Documentation2.java/** * &lt;pre&gt; * System.out.println(new Date()); * &lt;/pre&gt; * ////:~ 也可以像WEB那样运用HTML，对普通文本按照你自己所描述的进行格式化：12345678910//: object/Documentation3.java/** * You can &lt;em&gt;even&lt;/em&gt; insert a list: * &lt;ol&gt; * &lt;li&gt; Item one * &lt;li&gt; Item two * &lt;li&gt; Item three * &lt;/ol&gt; *////:~ 不要在嵌入式HTML中使用标题标签，如h1和hr，因为会和javadoc的产生冲突。所有类型的注释文档—–类、域和方法—-都支持嵌入式HTML。 2.8.4一些标签示例这里介绍一些可用于代码文档的javadoc标签。 1.@see:引用其他类@see标签允许用户引用其他类的文档。javadoc会在其生产的HTML文件中，通过@see标签链接到其他文档。格式如下：123@see classname@see fully-qualified-classname@see fully-qualified-classname#method-name 上述每种格式都会在生产的文档中加入一个具有超链接的“See Also”(参见)条目，但是javadoc不会检查你所提供的超链接是否有效。 2.{@link package.class#member label}该标签与@see极其相似，只是它用于行内，并且是用“label”作为超链接文本而不用“See Also”。 3.{@docRoot}该标签产生到文档根目录的相对路径，用于文档树页面的显式超链接。 4.{@inheritDoc}该标签从当前这个类的最直接的基类中继承相关文档到当前文档注释中。 5.@version该标签的格式如下1@version version-information 其中“version-information”可以是任何你认为适合包含在版本说明中的重要信息。如果javadoc命令使用了“-version”标记，那么就从生成的HTML文档中特别提取版本信息。 6.@author该标签格式如下：1@author author-information 其中“author-information”可以是任何你认为适合包含在作者说明中的任何信息，如电子邮件等。如果javadoc命令使用了“-author”标记，那么就从生成的HTML文档中特别提取作者信息。可以使用多个标签，以便列出所有作者。但是它们必须连续。 7.@since该标签允许你指定程序代码最早使用的版本，可以再HTML java文档中看到它们被用来指定所用的JDK版本情况。 8.@param该标签用于方法文档中，形式如下：1@param parameter-name description 其中，parameter-name是方法的参数列表中的标识符，description是可以延迟数行的文本，终止于新的文档标签出现之前。可以使用任意多种标签，大约每个参数都有一个这样的标签。 9.@return该标签用于方法文档中，格式如下：1@return description 其中，“description”用来描述返回值的含义，可以延续数行。 10.@throws“异常”，它们是由于某个方法调用失败而“抛出”的对象。格式如下：1@throws fully-qualified-class-name description 其中fully-qualified-class-name给出一个异常类的无歧义的名字。而该异常类在别处定义。description告诉你为什么此特殊的异常会在方法调用中出现。 11.@deprecated该标签用于支出一些旧特性已由改进的新特性取代。如果使用@deprecated标记的方法，则编译器会发布警告。在java SE5中，javadoc标签@deprecated已经被@Deprecated注解所替代。 2.8.5文档示例下面再回到第一个Java程序，但这次加上了文档注解。123456789101112131415161718192021//: object/HelloDate.javaimport java.util.*;/** The first Thinking in Java example program. * Display a string and today's date. * @author Bruce Eckel * @author www.MindView.net * @version 4.0 */public class HelloDate&#123; /** Entry point to class &amp; application. * @param args array of string arguments * @throws exception No exceptions throw */ public static void main(String[] args)&#123; System.out.println(\"Hello, it's: \"); System.out.println(new Date()); &#125; &#125; /* Output: (55% match)Hello, it's:Wed Oct 05 14:39:36 MDT 2005*///:~ 在这里用“：”作为特殊记号说明这是包含源文件名的注释行。而“///:~”代表源代码清单的结束。 2.9编码风格在“Java编程语言编码约定”中，代码风格是这样规定的：类名的首字母要大写，如果类名由多个单词构成，那么把它们并在一起，其中每个内部单词的首字母都采用大写形式。如：1class AllTheColorsOfTheRainbow&#123; //... 这种风格成为“驼峰风格”。其它所有内容—–方法、字段（成员变量）以及对象引用名称等，公认的风格与类的风格一样，只是标识符第一个字母采用小写。如：1234567class AllTheColorsOfTheRainbow&#123; int anIntegerRepresentingColors; void changeTheHueOfTheColor(int newHue)&#123; //... &#125; // ...&#125;","categories":[],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/tags/读书笔记/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"《Thinking in java》读书笔记(10)","slug":"《Thinking-in-java》读书笔记-10","date":"2017-06-21T03:12:55.000Z","updated":"2018-01-15T05:37:21.950Z","comments":true,"path":"2017/06/21/《Thinking-in-java》读书笔记-10/","link":"","permalink":"http://yoursite.com/2017/06/21/《Thinking-in-java》读书笔记-10/","excerpt":"第二章 一切都是对象2.5方法、参数和返回值许多程序设计语言（像C和C++）用函数这个术语来描述命名子程序；而在Java里却常用方法这个术语来表示。 Java的方法决定了一个对象能够接收什么样的消息。方法的基本组成部分包括：名称、参数、返回值和方法体。下面是它最基本的形式：1234ReturnType methodName(/* Argument list*/)&#123; /* Method body*/&#125;","text":"第二章 一切都是对象2.5方法、参数和返回值许多程序设计语言（像C和C++）用函数这个术语来描述命名子程序；而在Java里却常用方法这个术语来表示。 Java的方法决定了一个对象能够接收什么样的消息。方法的基本组成部分包括：名称、参数、返回值和方法体。下面是它最基本的形式：1234ReturnType methodName(/* Argument list*/)&#123; /* Method body*/&#125; 返回类型描述的是在调用方法之后从方法返回的值。Java中的方法只能作为类的一部分来创建。方法只有通过对象才能被调用，且这个对象必须执行这个方法调用。1234objectName.methodName(arg1, arg2, arg3);// how to call methodint x = a.f();// example for call method 以上返回类型必须和x的类型兼容。这种调用方法的行为通常别称为发送消息给对象。消息是f(),对象是a。 2.5.1参数列表方法的参数列表指定要传递给方法什么样的信息。这些信息都是对象形式。假设某个方法接受String为其参数，下面是具体定义，它必须置于某个类的定义内才能被正确的编译。123int storage(String s)&#123; return s.length()*2;&#125; 通过这个例子，还可以了解到return关键字的用法，它包括两方面：首先，它代表“已经做完，离开此方法”。其次，如果此方法产生了一个值，这个值要放在return语句后边。在这个例子中，返回值是通过计算s.length()*2这个表达式得到的。如果不想返回任何值，可以使用void（空）。1234boolean flag()&#123; return true;&#125;double naturalLogBase()&#123; return 2.718;&#125;void nothing()&#123; return;&#125;void nothing2()&#123;&#125; 若返回值是void，return关键字的作用只是用来退出方法。因此，没必要到方法结束时才离开，可以使任何地方。如果返回值不是void，那么需要返回一个正确类型的返回值。到此为止，读者或许觉得：程序似乎只是依稀裂带有方法的对象组合，这些方法以其他对象为参数，并发送消息给其他对象。其实大体上就是这样。 2.6构建一个Java程序在构建第一个Java程序之前，还必须了解其它一些问题。 2.6.1名字可见性名字管理对任何程序设计语言来说，都是一个重要的问题。如果某个程序的某个模块使用了一个名字，而其他人在这个程序的不同模块里也使用了相同的名字，那么怎样才能区分这两个名字并防止二者互相冲突呢？为了解决这个问题，C++通过几个关键字引入了命名空间的概念。而Java采用了一种全新的方法来避免上述问题。为了给类库生成一个不会与其他名字混淆的名字，Java的设计者希望程序员反过来使用自己Internet域名，因为这样保证它们肯定是独一无二的。例如：net.mindview.utility.foibles。反转域名后，句点就用来代表子目录的划分。在Java 1.0和1.1中，扩展名com、edu、org、net等约定为大写形式。在Java 2开发到一半时，设计者发现这样会引起一些问题，因此，现在整个包名都是小写了。 2.6.2运用其他构件如果想在自己的程序中使用预先定义好的类，那么编译器就必须知道怎么定位它们。为了解决一系列的问题，可以使用关键字import来准确的告诉编译器你想要的是什么。import指示编译器导入一个包，也就是一个类库。大多时候，我们使用预编译器附在一起的Java标准类库里边的构件。12import java.util.ArrayList;import java.util.*; 2.6.3static关键字通常来说，当创建类时，就是在描述那个类的对象的外观和行为。除非用new创建那个类的对象，否则，实际上并未获得任何对象。执行new来创建对象时，数据存储空间才被分配，其方法采供外界调用。有两种情形上述方法是无法解决的。一种情形是，只想为某特定域分配单一存储空间，而不去考虑究竟要创建多少对象，甚至根本就不创建任何对象。另外一种情形是，希望某个方法不与包含它的类的任何对象关联在一起。也就是说，即使没有创建对象，也能够调用这个方法。由static关键字定义的，即使从未创建某个类的任何对象，也可以调用其static方法或static域。有些面向对象语言采用类数据和类方法两个术语，代表那些数据和方法只是作为整个类，而不是类的某个特定对象而存在的。123class StaticTest&#123; static int i = 47;&#125; 即使你创建两个StaticTest的对象，StaticTest.i也只有一份存储空间，这两个对象共享同一个i。12StaticTest st1 = new StaticTest();StaticTest st2 = new StaticTest(); 在这里st1.i和st2.i指向同一存储空间，因此它们的值相同，都是47。引用static的变量有两种方法：st1.i或者StaticTest.i。类似的逻辑也应用与静态方法。可以使用ClassName.method()加以引用。一个static字段对每个类来说都只有一份存储空间，而非static字段则是对每个对象有一个存储空间。static方法的一个重要用法就是在不创建任何对象的前提下就可以调用它。正如我们将会看到的那样，这一点对定义main()方法很重要，这个方法是运行一个应用的入口。","categories":[],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/tags/读书笔记/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"《Thinking in java》读书笔记(9)","slug":"《Thinking-in-java》读书笔记-9","date":"2017-06-17T02:56:10.000Z","updated":"2018-01-10T03:21:05.022Z","comments":true,"path":"2017/06/17/《Thinking-in-java》读书笔记-9/","link":"","permalink":"http://yoursite.com/2017/06/17/《Thinking-in-java》读书笔记-9/","excerpt":"第二章 一切都是对象2.3永远不需要销毁的对象在大多数程序设计语言中，变量生命周期的概念，占据了程序设计工作中非常重要的部分。变量需要存活多长时间？如果想要销毁对象，那什么时候进行呢？","text":"第二章 一切都是对象2.3永远不需要销毁的对象在大多数程序设计语言中，变量生命周期的概念，占据了程序设计工作中非常重要的部分。变量需要存活多长时间？如果想要销毁对象，那什么时候进行呢？ 2.3.1作用域大多数过程型语言都有作用域(scope)的概念。作用域决定了在其内定义的变量名的可见性和生命周期。在C、C++和Java中，作用域有花括号的位置决定。例如：12345678910&#123; int x = 12; // Only x available &#123; int q = 96; //Both x &amp; q available &#125; // Only x available //q is out of scope&#125; 在作用域里定义的变量可用于作用域结束之前。任何位于“//”之后到行末的文字都是注释。缩排格式使Java代码更易于阅读。由于Java是一种自由格式（free-form）的语言，所以空格、制表符、换行都不会影响程序的执行结果。尽管一下代码在C和C++中是合法的，但是在Java中却不能这样书写：123456&#123; int x = 12; &#123; int x = 96;//illegal in java &#125;&#125; Java编译器将会报告变量x已经被定义过。 2.3.2对象的作用域Java对象不具备和基本类型一样的生命周期。当new创建一个Java对象时，它可以存活于作用域之外。所以假如你采用代码123&#123; String s = new String(\"a string\");&#125;//end of scope 引用s在作用域终点就消失了。然而，s指向的String对象仍然占据内存空间。不过在Java中可以通过Java的垃圾回收器(GC)，用来监视用new来创建的所有对象，当我们不在需要它的时候，释放这些对象的内存空间。这样就消除了这类编程问题(内存泄漏)。 2.4创建新的数据类型：类如果一切都是对象，那么是什么决定了某一类对象的外观和行为呢？就是说，是什么确定了对象的类型？这里并不是使用关键字“type”,大多数面向对象语言习惯使用关键字class。class这个关键字之后紧跟着的是新类型的名称。例如：1class ATyoeName&#123;/* Class body goes here*/&#125; 这样就引入了新的类型。可以使用new来创建这种类型的对象。1ATypeName a =new ATypeName(); 但是没有定义它的方法之前，他还不能去做更多的事情。（也就是说它还不能发送任何有意义的消息，设置可以说不能发送消息。） 2.4.1字段和方法一旦定义了一个类，就可以在类中设置两种类型的元素：字段（有时被称为数据成员）和方法（有时被称为成员函数）。12345class DataOnly&#123; int i; double d; boolean b;&#125; 尽管这个类除了存储数据之外什么也不做，但是仍旧可以像下面一样创建它的一个对象：1DataOnly data = new DataOnly(); 引用对象成员的方法：12345objectReference.member;// other eaxmplesdata.i = 47;data.d = 1.1;data.b = true; DataOnly类除了保存数据没别的用处，因为他没有任何成员方法。如果想了解成员方法的运行机制，就得先了解参数和返回值的概念。 基本成员默认值若类的某个成员是基本数据类型，即使没有初始化，Java也会确保它们获得一个默认值，不过这些初始化也许对你的程序来说并不正确，设置不合法，所以最好明确地对变量进行初始化。 基本类型 默认值 boolean false char ‘\\u0000’(null) byte (byte)0 short (short)0 int 0 long oL float 0.0f double 0.0d 然而上述初始化并不适合“局部”变量。","categories":[],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/tags/读书笔记/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"《Thinking in java》读书笔记(8)","slug":"《Thinking-in-java》读书笔记-8","date":"2017-06-15T10:24:49.000Z","updated":"2018-01-15T02:04:17.290Z","comments":true,"path":"2017/06/15/《Thinking-in-java》读书笔记-8/","link":"","permalink":"http://yoursite.com/2017/06/15/《Thinking-in-java》读书笔记-8/","excerpt":"第二章 一切都是对象尽管Java是基于C++的，但是相比之下，Java是一种更“纯粹”的面向对象程序设计语言。因为C++是C的一个超集，所以势必包括许多C语言不具备的特性，这些特性使C++在某些方面显得过于复杂。","text":"第二章 一切都是对象尽管Java是基于C++的，但是相比之下，Java是一种更“纯粹”的面向对象程序设计语言。因为C++是C的一个超集，所以势必包括许多C语言不具备的特性，这些特性使C++在某些方面显得过于复杂。 2.1用引用操纵对象每种编程语言都有自己的操纵内存中元素的方式。有时候，程序员必须注意将要处理的数据是什么类型的。你是直接操纵元素，还是用某种给予特殊语法的间接表示（C、C++是用指针）来操纵对象？创建一个String引用1String s; 但这里创建的只是引用，并不是对象。如果此时向s发送一个信息，就会返回一个运行时错误。因为s并没有被初始化。1String s = \"songyaxu\"; 这里用到了一个Java语言的特性，字符串可以用带引号的文本初始化。通常，必须对对象采用一种更通用的初始化方法。 2.2必须由你创建所有对象一旦创建了一个引用，就希望它能与一个新的对象相关联。通常使用new来实现这个目的。1String s = new String(\"songyaxu\"); 当然Java也提供了大量的过剩的现成类型。 2.2.1存储到什么地方程序运行时，对象是怎样进行放置安排的呢？特别是内存是怎样分配的呢？对这些方面的了解会对你有很大的帮助。有5个不同的地方可以存储数据: 序号 名称 说明 1 寄存器 这时最快的存储区，它位于处理器内部，但是寄存器的数量有限，所以寄存器根据需求进行分配。 2 堆栈 位于通用RAM（随机访问存储器）中，但通过堆栈指针可以从处理器那里获得直接支持。Java系统必须知道存储在堆栈内所以项的生命周期，这一约束限制了程序的灵活性，所以Java数据存储于对战中，特别是对象引用，但Java对象并不存储于其中。 3 堆 一种通用的内存池（位于RAM区）用于存放Java所以对象，对不同于堆栈的好处是：编译器不需要知道存储的数据的具体生命周期。 4 常量存储 常量值直接存储在程序代码内部，这样做是安全的，因为他们永远不会被改变 5 非RAM存储 如果数据完全存活于程序外，那么它可以不受程序的任何控制，在程序没有运行时也可以存在，例子是流对象和持久化对象 2.2.2特例：基本类型在程序中常用到的基本类型，它们需要特殊处理。Java要确定每种基本类型所占存储空间的大小。它们的大小并不像其他大多数语言那样随机器硬件架构的变化而变化。这种所占存储空间大小的不变性是Java程序比其他大多数语言编写的程序更具有可移植性的原因之一。 基本类型 大小 最小值 最大值 包装类型 boolean - - - Boolean char 16-bit Unicode 0 Unicode 2^16-1 Character byte 8 bits -128 +127 Byte short 16 bits -2^15 +2^15-1 Short int 32 bits -2^31 +2^31-1 Integer long 64 bits -2^63 +2^63-1 Long float 32 bits IEEE754 IEEE754 Float double 64 bits IEEE754 IEEE754 Double void - - - Void 所有数值类型都有正负号，所以不要去寻找无符号的数值类型。基本类型的包装器类，使得可以在堆中创建一个非基本对象，用来表示对的基本类型。12char c = 'x';Character ch = new Charater(c); 也可以是1Charater ch = new Charater('x'); 而且Java SE5的自动包装功能将自动地将基本类型转换为包装类型，并可以反向转换12Character ch = 'x';char c=ch; 高精度数字Java提供了两个用于高精度计算的类：BigInteger、BigDecimal.他们属于包装类型范畴，但是没有基本类型。BigInteger支持任意精度的整数。也就是说，在运算中，可以表示任意大小的整数，而不会丢失任何信息。BigDecimal支持任何精度的定点数，可以进行货币运算。 2.2.3Java中的数组Java主要的目标之一是安全性。Java确保数组会被初始化，而不能在它的范围之外被访问。这种检查是以每个数组上少量的内存开销及运行时的下标检查为代价的。但由此换来的是安全性和效率的提高，因此付出的代价是值得的。","categories":[],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/tags/读书笔记/"}]},{"title":"《Thinking in java》读书笔记(7)","slug":"《Thinking-in-java》读书笔记-7","date":"2017-06-14T10:36:54.000Z","updated":"2018-01-09T10:37:54.907Z","comments":true,"path":"2017/06/14/《Thinking-in-java》读书笔记-7/","link":"","permalink":"http://yoursite.com/2017/06/14/《Thinking-in-java》读书笔记-7/","excerpt":"","text":"第一章 对象导论1.14总结面向过程型语言：数据定义和函数调用。这样的程序容易把人搞迷糊，因为它们使用的表示术语更加面向计算机而不是你要解决的问题。OOP语言中虽然添加了许多新的概念，但是编写良好的Java程序通常要比过程型程序要简单的多，而且易于理解的多。面向对象程序设计带给人们的喜悦： 1.对于设计良好的程序，通过阅读它，就可以很容易的理解其代码。 2.通常，其代码也会很少，因为许多问题都可以通过重用现有的类库代码而得到解决。 这些天一直在看这本书，因为工作的原因，所以看得时间比较少，看得也比较慢，但是总算有一个好的开端。希望自己保持，把自己想看的书都看完。第一章看完还是有点慢，大概花了9天的时间。后边的章节内容比较多，东西也比较难懂，也许会更慢，但是自己唯一要做到的就是不求速度有多快，只求一点一点的看完，把东西嚼透。","categories":[],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/tags/读书笔记/"}]},{"title":"一些想法","slug":"一些想法","date":"2017-06-14T09:28:25.000Z","updated":"2018-01-09T09:31:15.927Z","comments":true,"path":"2017/06/14/一些想法/","link":"","permalink":"http://yoursite.com/2017/06/14/一些想法/","excerpt":"又开始找工作了，觉得好难啊。","text":"又开始找工作了，觉得好难啊。 之前来CSDN工作，觉得可以转正，真的挺不错的，那只是以前的想法，现在看来，人家说转正，也是如果到时候真的确认到不行的地步才会找你。无奈，本来这个项目就没有什么技术含量，所以你做的好人家也不会觉得你在这方面优秀。并不是说没有技术含量的项目不会体现一个人的优势，而是说这样一个项目根本无法体现你学习能力强等等的优势。现在公司不缺人，所以，没有必要养你这种没有经验，又需要教的闲鱼。自己一时不知道自己何去何从。有时候想，谁谁谁不是拿到了多少薪资，有时候又结合现状想到自己能找一份4k-5k工作先干着，等有了经验。有时候觉得自己也应该能拿到8K-9K吧。 现实就是这样。让你无法定位自己。因为你太渺小了，对于外面世界，别人有多强你不了解，别人有多弱，你也不了解。所以无法从整个行业来定位自己的水平。 不过有时候还是比较对自己有信心的。因为自己在班级里也是数一数二的编程大神，现在在社会混，虽然人变多了，变得复杂了。但是我们那些该有的东西还在。一编程就停不下来的情绪、有了成果就开心的和花一样的喜悦、乐意钻研的劲、还有编起程来不眠不休忘记吃饭的状态。我想这些东西都不会变。而且它会使得我们在社会中逐渐变得有一定的优势。加油。 想找一份工作，踏踏实实的干着。 现在我渴求的就是一份工作，让自己踏踏实实的干着，能满足自己在北京，租房子、吃饭的基本开销就可以。让父母不为我找工作担心。让我也静下来，开始我的事业生涯。 写这个博客的时候还是对自己有信心的。所以说一些自己的优点吧。 真的是非常喜欢编程，为了走这条路，还曾经在高三复习一年。自己在大学一开始学习C++到Java到数据库等，一直都是在编程。所以自己的理论性不是很强，实践能力非常强。还在最后的一个学期拿到了奖学金。自己也为了这些参加过北京大学暑期学校的ACM培训。也拿到过自治区级奖项，还参加过哈工大举行的ACMICPC的竞赛。觉得自己的大学生活还是非常棒的。自己一直觉得自己在程序设计语言这方面有着一定的天赋。学习比较快，会类比，能举一反三。 愿自己尽快的拿到一家企业的Offer，放下自己的心事。","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"《Thinking in java》读书笔记(6)","slug":"《Thinking-in-java》读书笔记-6","date":"2017-06-12T10:14:55.000Z","updated":"2018-01-15T02:04:58.822Z","comments":true,"path":"2017/06/12/《Thinking-in-java》读书笔记-6/","link":"","permalink":"http://yoursite.com/2017/06/12/《Thinking-in-java》读书笔记-6/","excerpt":"第一章 对象导论1.13Java与InternetJava只是众多程序设计语言中的一种，你有可能会问：它为什么如此重要？为什么它促进计算机编程语言向前迈进了革命性的一步？其实它不仅解决了传统的单机程序，而且还解决了万维网（WWW）上的程序设计。 1.13.1Web是什么Web看似很神秘，如果想要看清它的面貌，首先得理解客户端/服务系统，它是计算技术中另一个充满诸多疑惑的话题。","text":"第一章 对象导论1.13Java与InternetJava只是众多程序设计语言中的一种，你有可能会问：它为什么如此重要？为什么它促进计算机编程语言向前迈进了革命性的一步？其实它不仅解决了传统的单机程序，而且还解决了万维网（WWW）上的程序设计。 1.13.1Web是什么Web看似很神秘，如果想要看清它的面貌，首先得理解客户端/服务系统，它是计算技术中另一个充满诸多疑惑的话题。 1.客户端/服务器技术客户端/服务器技术的核心思想是：系统具有一个中央信息存储池(central repository of information),用来存储某种数据，它通常存储在数据库中，你可以根据需要将它分发给某些人员或机器集群。它的关键概念在于信息存储池的位置集中于中央，这使得它可以被修改，然后这些信息可以传播给信息消费者。信息存储池、用于分发信息的软件以及信息与软件所驻留的机器或机群的总称叫服务器。驻留在用户机器上的软件与服务器进行通信，以获取信息、处理信息，然后将它们显示在被称为客户机的用户机器上。客户端/服务器计算技术的基本概念并不复杂。问题在于你只有单一的服务器，却要同时为多个客户服务。这意味着必须保证一个客户插入的新数据不会覆盖另外一个客户插入的新数据，也不会在插入过程中丢失（这被称为事务处理）。最后一个最重要的性能问题是：可能在任意时刻都有成百上千的客户想服务器发送请求，所以任何小的延迟都会产生重大影响。为了将延迟最小化，程序员努力减轻处理任务的负载，通常是分散给客户端机器处理，但是有时也会使用所谓的中间件将负载分散给在服务器端的其他机器。（中间件也被用来提高可维护性。） 2.Web就是一台巨型服务器最初，只有一种很简单的单向过程：你对某个服务器产生一个请求，然后它返回给你一个文件，你的机器（也就是客户机）上的浏览器软件根据本地机器的格式来解读这个文件。但是很快人们就希望可以做的更多，人们希望实现客户端/服务器能力，使得客户可以将信息反馈给服务器。其实Web已经向前跨进了一大步：一段信息不经修改就可以在任意型号的机器上进行显示。因为浏览器只是显示器，它甚至不能执行最简单的计算任务。为了解决这一问题。人们采取了不同的方法，使得可以播放质量更好的动画和视频。剩下的问题通过引入客户端浏览器中运行程序的能力就能解决。这被称为“客户端编程”。 1.13.2客户端编程Web最初的“服务器-浏览器”设计是为了能够支持交互性内容，但是基于交互性完全有服务器提供。服务器产生静态页面，提供给只能解释并显示它们的客户端浏览器。基本的HTML（HyperText Markup Language,超文本标记语言）包含有简单的数据收集机制：文本输入框、复选框、单选框、列表和下拉式列表以及按钮—-它只能被编程来实现复位变淡上的数据或提交表单给服务器。这种提交动作通过所以的Web服务器都提供的通用网关接口（common gateway interface,CGI）传递。提交内容也会告诉CGI应该如何处理。几乎所有的语言都可以编写CGI程序，而Perl已经成最常见的选择，而现在Python已对其产生了巨大的冲击，因为它更强大且简单。CGI程序的响应时间依赖于所需发送的数据量的大小，以及服务器和Internet的负载。（此外，CGI程序启动也是非常慢的）。所有问题的解决方式就是“客户端编程”。客户端编程意味着Web浏览器能用来执行任何它可以完成的工作，使得返回给用户的结果更加迅捷，而且使得你的网站更加具有交互性。客户端编程的问题在于：它与通常意义上的编程十分不同，参数几乎相同，而平台却不同。本节剩余的部分对客户端编程的问题和方法作一概述。 1.插件客户端编程所迈出的最重要的一步就是插件（plug-in）的开发。通过这种方式，程序员可以下载一段代码，并将其插入到浏览器中适当的位置，以此来为浏览器增加新功能。 2.脚本语言插件引发了浏览器脚本语言（scripting language）的开发。通过使用某种脚本语言，你可以将客户端程序的源码直接嵌入到HTML页面中，解释这种语言的插件在HTML页面被显示时自动激活。而JavaScript可以在浏览器不需要任何插件的情况下得到支持。 3.JavaJava不仅是一种功能强大的、安全的、跨平台的、国际化的编程语言，而且它还在不断的扩展，以提供更多的语言功能和类库，能够优雅地处理在传统编程语言中很难解决的问题，例如并发、数据库访问、网络编程和分布式计算。Java是通过applet以及使用Java Web Start来进行客户端编程的。它提供一种分发软件的方法，一旦用户需要客户端软件时，就自动从服务器把客户端软件分发给用户。 4.备选方案Macromedia的Flex，它允许你创建基于Flash的与applet相当的应用。 5..NET与C曾几何时，Java applet的主要竞争对手是微软的ActiveX—–尽管它要求客户端必须运行在windows平台上。它的优势是：他们可以看得到Java在什么方面做得好，在什么方面做得还不够好，然后基于此去构建，并具备Java不具备的优点。这时Java出现以来，Java所碰到的真正的竞争。 6.Internet与Intranet当Web技术仅限于用于特定公司信息网络时，它就被称为Intranet（企业内部网）。Intranet比Internet提供了更高的安全性，因为可以物理的控制对公司内部的服务器的访问。 当人们对各种令人眼花缭乱的解决客户端编程问题的方案时，做好的方法就是进行性价比分析。 1.13.3服务器端编程前面的问题忽略了服务器端的编程，它是Java取得巨大成功的因素之一。用户所有进行服务器端的请求，需要通过修改数据库的，都必须由服务器的某些代码来处理。这就是所谓的服务器端编程。","categories":[],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/tags/读书笔记/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"《Thinking in java》读书笔记(5)","slug":"《Thinking-in-java》读书笔记-5","date":"2017-06-10T10:10:14.000Z","updated":"2018-01-15T02:05:15.555Z","comments":true,"path":"2017/06/10/《Thinking-in-java》读书笔记-5/","link":"","permalink":"http://yoursite.com/2017/06/10/《Thinking-in-java》读书笔记-5/","excerpt":"第一章 对象导论1.10对象的创建和生命周期在使用对象的时，最关键的问题之一就是它们的生成和摧毁方式。每个对象的生存都需要资源，尤其是内存。当我们不需要这个对象的时候，我们就需要摧毁它，使得资源可以被释放。 而你创建对象，使用它，并且摧毁它，看似简单，但是可能遇到相对复杂的情况。怎样才知道何时摧毁这些对象？对象数据位于何处？怎样控制对象的生命周期？","text":"第一章 对象导论1.10对象的创建和生命周期在使用对象的时，最关键的问题之一就是它们的生成和摧毁方式。每个对象的生存都需要资源，尤其是内存。当我们不需要这个对象的时候，我们就需要摧毁它，使得资源可以被释放。 而你创建对象，使用它，并且摧毁它，看似简单，但是可能遇到相对复杂的情况。怎样才知道何时摧毁这些对象？对象数据位于何处？怎样控制对象的生命周期？C++中认为效率控制是最重要的问题，所以给程序员提供了选择的权利。为了追求最大的执行速度，对象的存储空间和生命周期可以在编写程序是确定，这可以通过将对象置于堆栈或者静态存储区域内来实现。这种方式将存储空间分配和释放置于优先考虑的地位。还有一种方式是在被称为堆（heap）的内存池中动态的创建对象。这样可以直到运行时才知道需要多少对象，他们的生命周期如何,以及它们的具体类型是什么。动态方式有这样一个一般性的逻辑假设：对象趋向于变得复杂，所以查找和释放存储空间的开销不会对对象的创建造成重大的冲击。动态方式所带来的灵活性真是解决一般化编程问题的要点所在。Java完全采用了动态内存分配的方式。每当想创建新对象时，就要使用new关键字来构建此对象的动态实例。还有一个议题，就是对象生命周期。对于允许在堆栈上创建的对象的语言，编译器可以确定对象存活的时间，并可以自动销毁它。然而要是在堆上创建的对象，编译器对它的生命周期就一无所知。在像C++这样的语言中，必须通过编程来确定何时销毁对象，这可能因为不能正确的处理而导致内存泄漏。Java提供了垃圾回收器的机制，它可以自发现对象何时不再使用，继而销毁它。 1.11异常处理：处理错误自从编程语言问世以来，错误处理就始终是最困难的问题之一。一位涉及一个良好的错误处理机制非常困难，所以许多语言直接略去这个问题，将它交给程序库设计者处理，而这些设计者也只是提出一些不彻底的方案，使得这部分通常也只是被忽略。异常是一种对象，它从出错点被“抛出”，并被专门设计用来处理特定类型错误的相应异常处理器“捕获”。异常就像是与程序正确执行的路径并行的，所以它不会干扰正常的执行代码。异常提供了一种从错误状态进行可靠恢复的途径。现在不再是只能退出程序，你可以经常进行校验，并回复程序的执行，这些都有助于程序的健壮性。Java一开始就内置了异常处理，而且强制你必须使用它。值得注意的是，异常处理不是面向对象的特征—–尽管在面向对象语言中异常常被表示为一个对象。异常处理在面向对象语言出现之前就已经存在了。 1.12并发编程在计算机编程中有一个基本概念，就是在同一时刻处理多个任务的思想。最初，程序员们用所掌握的有关机器底层的只是来编写中断服务程序，主进程的挂起是通过硬件的终端来实现的。这虽然能解决问题，但是难度太大，而且不能移植。我们怎样才能办到把问题切分成多个可独立运行的部分（任务），从而提高程序的响应能力？在程序中，这些彼此独立运行的部分称为线程。上述概念被称为并发。通常线程只是一种为单一处理器分配执行时间的手段。但是如果系统支持多处理器，那么每个任务都可以指派给不同的处理器，并且它们是真正地并行执行。但是其实存在一个隐患：共享资源。如果多个任务都要访问一个资源，那么就会出现问题。为了解决这个问题：某个任务锁定某项资源，完成其任务，然后释放锁定资源，是其它任务可以使用这项资源。Java的并发是内置于语言中的，Java SE5已经添加了大量的额外的库支持。","categories":[],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/tags/读书笔记/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"《Thinking in java》读书笔记(4)","slug":"《Thinking-in-java》读书笔记-4","date":"2017-06-07T09:59:18.000Z","updated":"2018-01-15T02:05:38.452Z","comments":true,"path":"2017/06/07/《Thinking-in-java》读书笔记-4/","link":"","permalink":"http://yoursite.com/2017/06/07/《Thinking-in-java》读书笔记-4/","excerpt":"第一章 对象导论1.9容器当在解决某个特定问题需要创建多少个对象，或者它们将存活多少时间，那么久不可能知道如何存储这些对象。如何才能知道需要多少空间来创建这些对象呢？","text":"第一章 对象导论1.9容器当在解决某个特定问题需要创建多少个对象，或者它们将存活多少时间，那么久不可能知道如何存储这些对象。如何才能知道需要多少空间来创建这些对象呢？对于这问题而言，它的解决方案似乎过于轻率：创建另一种对象类型。这种新的对象类型持有对其他对象的引用。这个在大多数语言中都有数组类型来实现相同的功能。通常称这个为容器。容器：在任何时候都能扩充自己以容纳你置于其中的所有对象，因此不需要知道将来会把多少个对象置于容器中，只需创建一个容器对象，然后让他处理所有细节。每种OOP语言都有自己的容器 语言 容器 C++ 标准模板类库(Standard Template Library,STL) Object Pascal 可视化构件库(Visual Component Libray,VCL) Smalltalk 非常完备的容器集 一般语言只有一两钟通用容器。而在Java中，具有满足不同需求的容器。 容器名称 容器名称 List 用于存储序列 Map 用于简历对象之间的关联 Set 每种对象类型只持有一个 还有更多构件，如：队列、树、堆栈等。从设计的观点来看，真正需要的只是一个可以被操作的，从而解决问题的序列。但是一般单一的容器不足以满足所有需求。那么需要不同的容器的原因有两个： 1.不同的容器提供了不同的类型的接口和外部行为。 2.不同的容器对于某些操作具有不同的效率。 差异的对比 ArrayLsit LinkedList 随机访问 花费固定时间 访问越靠近表尾的元素，话费时间越长 插入元素 时间开销大 时间开销小 1.9.1参数化类型在Java SE5出现之前，容器存储的对象都只具有Java中的通用类型：Object.单根继承结构意味着所有的东西都是Object类型。所以可以存任何东西，很容易复用。但是如果我们存储一个对象时，由于只能存储Object类型，所以我们需要向上转型为Object,使得我们在取出的时候不知道在置入容器之前的具有使用接口的对象是什么。所以我们需要使用向下转型。向上转型是安全的，但是向下转型几乎是不安全的。如Circle是Shape类型，但不知道某个Object是Circle类型还是Shape类型。那么创建一个知道自己所保存的对象类型的容器，不是更有意义吗？所以在Java SE5的时候增加了参数化类型，在Java中称它为范型。例如创建一个存储Shape的ArrayList： 1ArrayList&lt;Shape&gt; shapes = new ArrayList&lt;Shape&gt;();","categories":[],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/tags/读书笔记/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"决定","slug":"决定","date":"2017-06-07T09:26:29.000Z","updated":"2018-01-09T09:27:37.441Z","comments":true,"path":"2017/06/07/决定/","link":"","permalink":"http://yoursite.com/2017/06/07/决定/","excerpt":"每个人的想法都是不同的，但是请不要把你的想法灌输给别人。 有一句话叫既来之，则安之。为什么你来着工作却不认真，其实每一份工作都一样，无论正式还是实习。都要脚踏实地的去做。这是态度，和其它无关。","text":"每个人的想法都是不同的，但是请不要把你的想法灌输给别人。 有一句话叫既来之，则安之。为什么你来着工作却不认真，其实每一份工作都一样，无论正式还是实习。都要脚踏实地的去做。这是态度，和其它无关。 我搞笑你今天所说的话，但是我很感谢这种话你会对我说，而不是选择不和我说，默默地去做。但是我和你不是一类人。请不要用你的想法去约束我。谢谢。 还有就是写程序的时候，我做的只是我自己想要完成的东西。我做的软件不一定是给经常使用的客户做的。更有可能是仅仅只使用一次的人。所以很多字段的数据校验是非常有必要的。你不做可以，请不要要求我。 每个人都有自己的决定，你按照你自己的走就行了。我也有自己的想法。OK？","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"《Thinking in java》读书笔记(3)","slug":"《Thinking in java》读书笔记-3","date":"2017-06-06T15:32:35.000Z","updated":"2017-06-07T07:48:02.987Z","comments":true,"path":"2017/06/06/《Thinking in java》读书笔记-3/","link":"","permalink":"http://yoursite.com/2017/06/06/《Thinking in java》读书笔记-3/","excerpt":"第一章 对象导论1.7伴随多态的可互换对象在处理类型的层次结构时，经常想把一个对象不当做它所属的特定类型来对待，而是将其当做其基类来看待。在“几何形”的例子中，方法操作都是泛化（generic）的形状,而不关心它们是哪种几何图形。","text":"第一章 对象导论1.7伴随多态的可互换对象在处理类型的层次结构时，经常想把一个对象不当做它所属的特定类型来对待，而是将其当做其基类来看待。在“几何形”的例子中，方法操作都是泛化（generic）的形状,而不关心它们是哪种几何图形。下图中，BirdController对象仅仅处理泛化的Bird对象，而不了解它们的确切类型。从BirdController的角度来看，这么做非常方便，因为不需要写特别的代码来判定他们要处理的Bird对象的确切类型或行为。当move()方法别调用时，即便忽略Bird的具体类型，也产生正确的行为（Goose（鹅）走、飞或者游泳，Penguin(企鹅)走或者游泳），那么，这时如何发生的呢？ 它的答案就是面向对象编程的重要妙诀：编译器不可能产生传统意义上的函数调用。一个非面向对象编程的编译器产生的函数调用会引起所谓的前期绑定，为了解决这个问题，面向对象的程序设计语言使用了后期绑定。前期绑定：也叫静态绑定，在程序执行前方法已经被绑定（也就是说在编译过程中就已经知道这个方法到底是哪个类中的方法），此时由编译器或其它连接程序实现。例如：C。针对java简单的可以理解为程序编译期的绑定；这里特别说明一点，java当中的方法只有final，static，private和构造方法是前期绑定。后期绑定：也叫动态绑定，在运行时根据具体对象的类型进行绑定。若一种语言实现了后期绑定，同时必须提供一些机制，可在运行期间判断对象的类型，并分别调用适当的方法。也就是说，编译器此时依然不知道对象的类型，但方法调用机制能自己去调查，找到正确的方法主体。不同的语言对后期绑定的实现方法是有所区别的。但我们至少可以这样认为：它们都要在对象中安插某些特殊类型的信息。动态绑定的过程： 1.虚拟机提取对象的实际类型的方法表； 2.虚拟机搜索方法签名； 3.调用方法。 具体说明：Java前期（静态）绑定和后期（动态）绑定在某些语言中，必须明确地声明希望某个方法具备后期绑定属性所带来的灵活性，如C++是使用virtual关键字来实现的。在java中方法默认是动态绑定的，不需要关键字来实现，其他语言则不是。为了说明这里编写一段代码，他忽略类型的具体细节，仅仅和基类交互。 12345void doSomething(Shape shape)&#123; shape.erase(); // ... shape.draw();&#125; 这个方法可以与任何Shape进行对话。如果程序中其他部分用到doSomething()这个方法： 123456Circle circle = new Circle();Triangle triangle = new Triangle();Line line = new Line();doSomething(circle);doSomething(triangle);doSomething(line); 对doSomething()多的调用会自动地正确处理，而不管对象的确切类型。把导出类看做是它的基类成为向上转型(upcasting)。 这段代码并没有说 如果时Circle要怎么做，如果是Square要怎么做。如果编写了这种代码，肯定是杂乱不堪的。在后期加入新的类型还需要去改。很麻烦。而是当传给一个匿名的Shape时，也会根据这个Shape的实际类型产生正确的行为。 1.8单根继承结构在OOP中，C++、Java等所有OOP语言的所有的类最终都继承自单一的基类。这个累的名称就是Obejct。我们称之为单根继承。 单根继承保证所有对象都具备某些功能。所有对象很容易地在堆上创建，而参数传递也得到了极大的简化。单根继承是垃圾回收器实现变得简单的多。而来及回收器正是Java相对于C++的重要改进之一。","categories":[],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/tags/读书笔记/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"听完这首歌忘记所有的一切","slug":"听完这首歌忘记所有的一切","date":"2017-06-05T09:22:37.000Z","updated":"2018-01-09T09:28:12.265Z","comments":true,"path":"2017/06/05/听完这首歌忘记所有的一切/","link":"","permalink":"http://yoursite.com/2017/06/05/听完这首歌忘记所有的一切/","excerpt":"多幸运","text":"多幸运 听着突然听到了这首歌，回忆起很多事情。想到了很多。想到当初的执着是不是不应该。也许吧。都说时间能冲淡一切。这个是真的没有错。但是当初的选择自己绝不会后悔的。","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"《Thinking in java》读书笔记(2)","slug":"《Thinking in java》读书笔记-2","date":"2017-06-04T15:39:35.000Z","updated":"2017-06-06T09:26:25.273Z","comments":true,"path":"2017/06/04/《Thinking in java》读书笔记-2/","link":"","permalink":"http://yoursite.com/2017/06/04/《Thinking in java》读书笔记-2/","excerpt":"第一章 对象导论1.3每个对象都提供服务理解或者开发一个程序的时候，做好的方法之一就是将对象想象为“服务提供者”。","text":"第一章 对象导论1.3每个对象都提供服务理解或者开发一个程序的时候，做好的方法之一就是将对象想象为“服务提供者”。那么为了实现更多的服务就是去创建提供服务的一系列对象。将对象看做服务提供者的好处就是：有助于提高对象的内聚性。高内聚是软件设计的基本质量之一。 但是不宜将所有的功能都交给一个对象，我们可以创建更多对象去完成不同的功能。 1.4被隐藏的具体实现主要引出类的访问控制。访问控制的存在原因： 1.让客户端程序员无法触及他们不应该触及的部分。 2.允许库设计者可以改变类内部的工作方式而不用担心会影响到客户端程序员。 Java用是哪个关键字在类的内部设定边界(access specifier访问指定词):public private protected.还有一种就是默认访问权限通常称为 包访问权限 access specifier 说明 public 紧随其后的元素任何人都可以使用。 private 除了类创建者和类型的内部方法之外的任何人都不能访问的元素。 protected 和private差不多，在于仅在于继承的类可以访问protected成员，但是不能访问private成员 default 类可以访问在同一个包中的其他类的成员，但是包之外，这些成员如同指定了private一样。 1.5复用具体实现代码复用是面向对象程序设计语言所提供的最了不起的优点之一。最简单地复用某个类的方式就是直接使用该类的一个对象。也可以以组合(composition)的方式合成新的类。如果是动态的组合，我们也叫它为聚合。组合经常被视为“has-a”拥有的关系。就像汽车拥有引擎。组合带来了极大的灵活性。新类的成员对象通常都声明为private.实际上，在新建类时，应该首先考虑组合关系。因为它更简单，更灵活。采用这种方式，设计会变得更加清晰。虽然继承也创建了新类，但是继承并不具备这么好的灵活性。随意再设计程序的时候要考虑哪里要用到继承，哪里要用到组合。 1.6继承对象本身就是一个很方便的工具，使得你可以通过概念将数据和功能封装到一起。并使用class关键字表示，形成编程中的基本模块。但是如果有一个功能相似的类的话，那么我们还得必须再创建一个。通过集成的方法，我们解决了这个麻烦。 当继承现有的类，也就创造了新的类型，这个新类型不仅包括现有的类型的所有成员，还有他复制基类的接口。 也就是说，基类和导出类具有相同的对象。 通过继承而产生的类型等价性是理解面向对象程序设计方法内涵的重要门槛。 如果基类和导出类永远相同的类型，还拥有相同的行为，这就没有什么特别的意义。那么有2种方法可以使基类和导出类产生差异。 1.直接在导出类添加新的方法。 2.覆盖（overriding）那个方法。 虽然是相同方法，但是在新类型中做的事情却不同。 1.6.1“是一个”与“像是一个”关系如果继承只覆盖基类的方法，就意味着基类和导出类是完全相同的类型。因为他们具有相同的接口。结果就是一个导出类可以完全替代基类，这种纯粹替代，通常被称为替代原则。我们称之为is-a(是一个)。如：一个圆是一个几何形状。有时候必须在新类型中添加新的接口，这样新类型完全可以替代基类，但是替代并不完美，以为基类无法访问新的接口。我们叫着为is-like-a(像是一个)。这时两张不同的继承方式，我们在使用的时候应该注意场景。","categories":[],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/tags/读书笔记/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"《Thinking in java》读书笔记(1)","slug":"《Thinking in java》读书笔记-1","date":"2017-06-01T15:58:46.000Z","updated":"2017-06-05T02:42:06.759Z","comments":true,"path":"2017/06/01/《Thinking in java》读书笔记-1/","link":"","permalink":"http://yoursite.com/2017/06/01/《Thinking in java》读书笔记-1/","excerpt":"第一章 1.1-1.2 第一章 对象导论其中前言说到OOP是计算机表达媒体的重要组成部分，说到本章将讲解OOP的编程方法和编程理论。","text":"第一章 1.1-1.2 第一章 对象导论其中前言说到OOP是计算机表达媒体的重要组成部分，说到本章将讲解OOP的编程方法和编程理论。 1.1抽象过程编程语言都是抽象机制。 人们在现实生活中解决问题的复杂性取决于抽象的类型和质量，其实编程也是一样。如果想更好的完成计算机语言的编程，应该把专注点放在要解决的问题的结构上来，而不是计算机的结构。许多编程语言在前期完成了解决某种特定类型的问题，却无法完成超出这个领域的问题。而面向对象的编程可以解决这一难题，使得程序可以通过添加对象，是自己适合某个特定问题的解决上。而这种面向对象语言有5个基本特性： 1.万物皆为对象。 2.程序是对象的集合，它们通过发送消息来告知彼此所要做的。 3.每个对象都有自己的由其他对象所构成的存储。 4.每个对象都拥有其类型。 5.某一特定类型的所以对象都可以接收同样的信息。 Booch也对对象提出了一个简洁的描述：对象具有状态、行为和标识。 1.2每个对象都有一个接口几乎所有的对象都是用class关键字。类描述了具有相同特性和行为的对象的结合。当我们看到类型时，可以将它看做类来考虑，反之亦然。一个类被创建，就可创建类的任意个对象，然后去操作他们。面向对象程序设计的挑战之一就是在问题空间的元素和解空间的对象之间创建一对一的映射。那么如何获得有用的对象呢？必须有某种方式产生对对象的请求，使得对象完成各种任务。每个对象都只能满足某些请求，这些请求有对象的接口（interface）定义。决定接口的便是类型。以电灯泡为例：Light it = new Light();il.on();","categories":[],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/tags/读书笔记/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"六一儿童节快乐","slug":"六一儿童节快乐","date":"2017-06-01T09:21:09.000Z","updated":"2018-01-09T09:25:55.329Z","comments":true,"path":"2017/06/01/六一儿童节快乐/","link":"","permalink":"http://yoursite.com/2017/06/01/六一儿童节快乐/","excerpt":"6.1儿童节快乐^-^。 时间过得很快啊，一年已经过去了一半啦，今天给自己开启一个新的里程碑。新的合租生活的开始，新的体验的开始。新的计划的开始。","text":"6.1儿童节快乐^-^。 时间过得很快啊，一年已经过去了一半啦，今天给自己开启一个新的里程碑。新的合租生活的开始，新的体验的开始。新的计划的开始。昨晚才知道和我一起合租的其他几个房间住的都是女孩子…，看来我的多多注意我的举止行为，更加要注意个人卫生问题了。 然后现在呢有了自己的小空间，这样也就说到了很早就想要去做的事情，那就是学习。 新计划开始了，打算重新从头开始好好读《Thinking in java》这本书。虽然以前读了一些，但是觉得自己都忘记了，现在自己要从新开始读。每天写好读书笔记。忘记的时候还可以看看。 以前想要坚持做得事情好像都被打断了，还是需要自己的努力坚持吧。这也算是读书笔记的第一篇吧。加一个链接~ 加油！","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"The mood may be better","slug":"The-mood-may-be-better","date":"2017-05-31T09:15:10.000Z","updated":"2018-01-09T09:17:26.829Z","comments":true,"path":"2017/05/31/The-mood-may-be-better/","link":"","permalink":"http://yoursite.com/2017/05/31/The-mood-may-be-better/","excerpt":"","text":"搬家啊，不算麻烦。 本想着搬家一定很麻烦，没有想到还算轻松。想想自己一开始来的时候，那才叫一个麻烦呢。每天都背着一大书包的书、电脑、衣服，满北京的找工作。真心辛苦，但是不知道自己是怎样熬过那两个星期的。想想也是很佩服自己。 虽然自己一个人生活很艰苦，但是觉得还是很不错的，和别人住在一起有很多不便，也不方便自己学习。发现自己还是适合一个人，这样能让自己冷静下来学习。 在这么一个繁华的大都市，想要站稳了，需要付出的努力是很多的。不仅仅是找工作那么点点的辛苦，更多的是在夜深人静时的认真学习、在酷暑下的认真工作、在生活中的认真做人、脚踏实地的认真做事。","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"NoTitle","slug":"NoTitle","date":"2017-05-27T09:13:07.000Z","updated":"2018-01-15T02:06:49.907Z","comments":true,"path":"2017/05/27/NoTitle/","link":"","permalink":"http://yoursite.com/2017/05/27/NoTitle/","excerpt":"因为之前有一段时间没在公司，而是回学校忙毕设，所以没有更新博客。 今天真的是，哎╮(╯▽╰)╭，不知道怎么说，早晨还在等7点钟的闹铃，却忘记今天是周六，没有闹铃的，因为下周二端午节的关系，所以今天需要上班，而我的闹铃只有周一到周有，所以是等不到了，幸好室友在7：30的时候提醒了我，不然肯定要迟到（结果还是迟到了…..）。 说句实在话，其实7：40出来都不会迟到，无奈今天公交堵得水泄不通，而我看见了，但是因为自己有点累，所以不想骑自行车去坐地铁，结果就走上了迟到的不归路。整整是堵了1个小时…..","text":"因为之前有一段时间没在公司，而是回学校忙毕设，所以没有更新博客。 今天真的是，哎╮(╯▽╰)╭，不知道怎么说，早晨还在等7点钟的闹铃，却忘记今天是周六，没有闹铃的，因为下周二端午节的关系，所以今天需要上班，而我的闹铃只有周一到周有，所以是等不到了，幸好室友在7：30的时候提醒了我，不然肯定要迟到（结果还是迟到了…..）。 说句实在话，其实7：40出来都不会迟到，无奈今天公交堵得水泄不通，而我看见了，但是因为自己有点累，所以不想骑自行车去坐地铁，结果就走上了迟到的不归路。整整是堵了1个小时…..中途有人下车，我还是选择赌一把，我要试试能堵多长时间，结果我和自己开了一个玩笑。最终自己迟到了1个小时。 其实吧，人生中很多东西都看运气的。比如说我来CSDN实习，真的是运气。之前看好的一个公司，自己很想留在那里，却被无情的非技术的二面拒之门外了。就在那晚刚好看见了招聘的信息。然后就投了，第二天就给我打电话说让我面试。面试当前就得知自己准备一些上班需要准备的东西。 周二就开始来上班了，真的很快。 也许什么时候一转身就遇见了你。也说不定呢。很期待。 自己也是想了很久想不到主题，那就No Title吧。","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"努力吧，少年","slug":"努力吧，少年","date":"2017-05-26T09:11:42.000Z","updated":"2018-01-15T02:06:31.432Z","comments":true,"path":"2017/05/26/努力吧，少年/","link":"","permalink":"http://yoursite.com/2017/05/26/努力吧，少年/","excerpt":"看了再多也没有用，想了再多也是白想。 现在的自己应该已经认识到那些事情是不可能的了，让自己不要再去想了，总之慢慢的自己会选择放弃吧，也许也会选择坚持，但是自己知道坚持的结果就是，她不会和你在一起的。 总是要放弃的吧，专注自己的事业，不要把心思放在她身上。那些东西都会是虚无缥缈的，自己之前对她做了这么多，最后换来的还不是这样的结果。","text":"看了再多也没有用，想了再多也是白想。 现在的自己应该已经认识到那些事情是不可能的了，让自己不要再去想了，总之慢慢的自己会选择放弃吧，也许也会选择坚持，但是自己知道坚持的结果就是，她不会和你在一起的。 总是要放弃的吧，专注自己的事业，不要把心思放在她身上。那些东西都会是虚无缥缈的，自己之前对她做了这么多，最后换来的还不是这样的结果。也许她是狠心想要让你放弃才故意不去理你了。 现在自己所要做的事情就是把自己的工作做好，认真学习自己不会的东西，学习工作相关的东西，让自己变得对企业有价值，让自己找到一份好的工作，好好报答自己的父母。 其实还是忙起来好，什么都不会去想，自己还是以前那个自己，一写起代码来就停不下来，总要有个结果。相信自己会在这方面做的很好，相信自己以后一会变成一个技术大牛吧。 为此而努力吧！fighting！","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"想念那些日子","slug":"想念那些日子","date":"2017-05-08T09:09:02.000Z","updated":"2018-01-15T02:06:17.548Z","comments":true,"path":"2017/05/08/想念那些日子/","link":"","permalink":"http://yoursite.com/2017/05/08/想念那些日子/","excerpt":"时间过得真快，来北京的日子也已经有78天了，实习也有2个月了。 现在的自己还是很怀念上学的日子，每每想起来都有不同的心情。虽然在学校的日子里有很多烦心的事情，但是总是开心的，现在在公司里不想上班，好像就和当初在宿舍里不想上课的心情是一样的。 但是发现自己的心境确实不同了，之前自己找工作的时候好像各种担心自己找不到工作，现在自己就算不能在这里转正也无所谓了。总有一个公司会收留我的。不知道是哪里来的信心。想一想过几天就要答辩了，我本打算少请几天假，多留在公司里忙项目，但是今天听到了领导的一些话，觉得自己还是可以多请几天假，多和自己的大学同学玩一玩，毕竟大学的的时间还剩不多了。想到这里感觉自己的眼泪好像都要流出来了，不知道为什么。","text":"时间过得真快，来北京的日子也已经有78天了，实习也有2个月了。 现在的自己还是很怀念上学的日子，每每想起来都有不同的心情。虽然在学校的日子里有很多烦心的事情，但是总是开心的，现在在公司里不想上班，好像就和当初在宿舍里不想上课的心情是一样的。 但是发现自己的心境确实不同了，之前自己找工作的时候好像各种担心自己找不到工作，现在自己就算不能在这里转正也无所谓了。总有一个公司会收留我的。不知道是哪里来的信心。想一想过几天就要答辩了，我本打算少请几天假，多留在公司里忙项目，但是今天听到了领导的一些话，觉得自己还是可以多请几天假，多和自己的大学同学玩一玩，毕竟大学的的时间还剩不多了。想到这里感觉自己的眼泪好像都要流出来了，不知道为什么。来一张合影： 现在想一想还是挺想上学的，如果自己能考研，考上一个好点的学校，那该有多好啊。","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"此时此刻的心情","slug":"此时此刻的心情","date":"2017-05-04T09:54:37.000Z","updated":"2018-01-08T09:56:15.175Z","comments":true,"path":"2017/05/04/此时此刻的心情/","link":"","permalink":"http://yoursite.com/2017/05/04/此时此刻的心情/","excerpt":"欢迎来到我的博客 也欢迎你们访问我的CSDN技术博客:并非菜鸟 自己的大部分技术博客还是在CSDN上写，而且自己的时间也不是很多，所以Github上边的博客也不是很多。之前很少有时间写博客的，现在工作了，也就会有时间去写了。 每天都觉得自己没有那么多的时间，也不知道时间都去了哪里。但是大部分时间都被自己浪费了吧。","text":"欢迎来到我的博客 也欢迎你们访问我的CSDN技术博客:并非菜鸟 自己的大部分技术博客还是在CSDN上写，而且自己的时间也不是很多，所以Github上边的博客也不是很多。之前很少有时间写博客的，现在工作了，也就会有时间去写了。 每天都觉得自己没有那么多的时间，也不知道时间都去了哪里。但是大部分时间都被自己浪费了吧。记得自己上大学的时候，每天中午都是别人睡醒了，自己才躺下，尤其是到了学期期末的时候，就连在路上都不敢耽误一点。每天晚上都到1、2点钟才睡，自己做了什么，自己并不知道。有些时候是为了赶学期期末的大作业在写代码。但是大多数的时候都是在看一些视频吧。记得有时候半夜3、4点钟的时候，突然看起Mybatis的教学视频，然后停不下来了。结果第二天没起来。自己现在想一想，那都是因为自己太贪玩造成的结果。自己平时学习的东西和知道的东西挺多的，但是最后自己发现对那些东西只是一个知道，甚至可能连那个东西是什么？做什么用的都不知道。 真心的希望自己能够改掉这些恶习，投入到自己平时的学习中来。让自己得到提升。现在工作了，感觉有事情做，每一天都很充实，都很快。每当自己没有事情的时候都很难受，希望自己能找点事做。 想到自己上大学的时候参加过很多的ACM的比赛，也拿到过奖。想到去哈工大去参加比赛的事情，觉得自己的大学还是没有白上。想到自己在班级中也算是一个会编程的大神还是很厉害的。想到自己平时帮助过很多同学解决了那么多的BUG，自己还是很佩服自己的。想到这些，现在自己还是对自己很有信心的，相信自己对代码、程序是有一定的认识和了解的。觉得自己生下来对这个来感。要不然也不能写代码入了迷，都忘记吃饭。希望自己能够在这条路上走的更远。","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"welcome","slug":"welcome","date":"2017-05-03T09:45:44.000Z","updated":"2018-01-08T09:57:01.275Z","comments":true,"path":"2017/05/03/welcome/","link":"","permalink":"http://yoursite.com/2017/05/03/welcome/","excerpt":"欢迎来到我的博客，这是我的第一篇博客，这个博客经过我很长时间，反反复复的搞，终于搞得像个样子了，终于算是成功了，然后在搞这个博客的前前后后中，学到了很多东西。了解了很多。 很早我就有了Github账户，可是那时自己还不知道Git怎么用，然后就跑到网上买了一本书叫《Git权威指南》的书，但是自己并没有看多少。 然后自己就在另外一个网站上学习了Git的相关课程。大概算是有一个了解吧。","text":"欢迎来到我的博客，这是我的第一篇博客，这个博客经过我很长时间，反反复复的搞，终于搞得像个样子了，终于算是成功了，然后在搞这个博客的前前后后中，学到了很多东西。了解了很多。 很早我就有了Github账户，可是那时自己还不知道Git怎么用，然后就跑到网上买了一本书叫《Git权威指南》的书，但是自己并没有看多少。 然后自己就在另外一个网站上学习了Git的相关课程。大概算是有一个了解吧。 后来在Github上无意间看到了Github Pages,然后自己按照相应的介绍，自己也是搭建起来自己的博客，但是那会还不到了解MarkDown怎么弄，也不知道如何使用Jekll创建自己的博客。 不过自己看到网站里边的资源全是静态的，所以自己也是改了一些文件，然后生成可一个主页。 后来才知道Jekll是一个工具，主要是使用的Ruby,而现在自己建立起来的Github Pages 时使用的Hexo,使用的语言是Node.js而且自己对如何使用Hexo还是了解了不少。 在创建博客的过程中，我学到了很多关于Git的相关知识，觉得自己还是很充实的。而且自己也终于建起自己的Github Pages了,很开心。 不过现在自己也在纠结一件事情，那就是以后写博客到底在哪里写？","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]}]}